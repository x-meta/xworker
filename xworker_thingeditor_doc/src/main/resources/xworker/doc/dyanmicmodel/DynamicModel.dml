^1618031022908
@
sname
DynamicModel
slabel
动态模型
stype
thingDesc
sgroup
dynamicModel
sgroupDescriptor
true
sicon
icons/html.png
sth_sortWeight
-9000
sstyledTextForInsert
parentContext.parentContext.codeText
suseTargetThingDoc
false
ssimpleBrowser
true
Sdescription
#$@text#$@
<h1>动态模型</h1>

<p>&nbsp; &nbsp; &nbsp;本文介绍动态模型编程的基本概念和方法。</p>

<h2>1.基本概念</h2>

<h3>1.1.使用结构化的数据编程</h3>

<p>&nbsp; &nbsp; 动态模型使用结构化的数据来编程，这些结构化的数据可以用XML来表示，也可以简单的理解为可以使用XML来编程。</p>

<p>&nbsp; &nbsp; 如下面的XMl就是一个动态模型的程序。</p>

<pre class="brush:xml;">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Shell name=&quot;shell&quot; descriptors=&quot;xworker.swt.widgets.Shell&quot; text=&quot;TestShell&quot;&gt;
    &lt;FillLayout name=&quot;FillLayout&quot;&gt;&lt;/FillLayout&gt;
    &lt;Browser name=&quot;Browser&quot; url=&quot;https://www.xworker.org&quot;&gt;&lt;/Browser&gt;
    &lt;GroovyAction name=&quot;init&quot;  code=&quot;println &amp;quot;Hello World!&amp;quot;;&quot;&gt;&lt;/GroovyAction&gt;
&lt;/Shell&gt;</pre>

<h3>1.2.编程理念</h3>

<p>&nbsp; &nbsp; 动态模型使用结构化的数据编程。它的基本理念是当我们使用数据时，可以根据不同的场合和需要赋予它不同的角色，我们根据赋予数据的角色来理解和使用数据。</p>

<h3>1.3.数据的基本角色</h3>

<p>&nbsp; &nbsp; 动态模型赋予结构化数据的基本角色。</p>

<h4>1.3.1.模型和事物</h4>

<p>&nbsp; &nbsp; 模型和事物是一种抽象的角色，是数据的一种称呼，一般用于想要用数据表示一些东西但并不需要明确是什么东西的时候。</p>

<p>&nbsp; &nbsp; 在动态模型里数据可以使用XML来表示，动态模型认为每一个XML的节点都可以是独立的模型和事物，因此一个模型可以包含属性（XML节点中的属性）和子模型（XML的子节点）。</p>

<h4>1.3.2.动作</h4>

<p>&nbsp; &nbsp; 动态模型是一种编程方法，因此我们需要数据能够变成可执行的程序。在动态模型里假设每一个模型都可以转化为动作，而动作是可以执行的，类似方法和函数。</p>

<h4>1.3.3.对象</h4>

<p>&nbsp; &nbsp; 由于一个模型可以含有属性和子模型（1.3.1.的定义），而任何模型都可以执行（1.3.2的假设），因此可以把一个模型的某些子节点当成它的行为，从而可以把一个模型看作是对象。</p>

<h4>1.3.4.描述者</h4>

<p>&nbsp; &nbsp; 描述者是用于描述模型的模型，描述者也可以看作是模型的类，用于描述模型的结构和行为。在动态模型里，一个模型的描述者可以是任意模型，并且模型继承描述者的行为。</p>

<h4>1.3.5.继承</h4>

<p>&nbsp; &nbsp; 在动态模型里，一个模型可以继承除了自身之外的其它任意模型，从而继承被继承模型的行为。</p>

<h3>1.4.面向对象</h3>

<p>&nbsp; &nbsp; 在动态模型里，通过赋予数据的基本角色，动态模型实际上实现了面向对象的编程方法。这里就不详细解释了，具体可以在编程时体会。</p>

<h2>2.动态模型的实现</h2>

<p>&nbsp; &nbsp; 实现动态模型编程的核心是如何解释执行一个模型的方法。</p>

<ol>
	<li>在上面的1.3.1.中假设了任意模型都可以转化为动作来执行，具体方法是把模型作为对象，去执行对象的为run的方法。</li>
	<li>模型的run方法还是模型（见1.3.3，使用模型的子节点来定义模型的行为），因此执行run方法回到步骤1.</li>
	<li>以上是一个递归的方法，如要让递归能够终止，那么一些模型是由引擎直接执行的。</li>
</ol>

<p>&nbsp; &nbsp; 以上是如何执行一个模型的方法。比如XWorker的动态模型引擎是使用Java实现的，模型名为JavaAction的模型是由引擎直接执行的，即执行JavaAction并不需要执行它的run方法，而是由引擎直接解释执行。</p>

<pre class="brush:xml;">
&lt;JavaAction name=&quot;run&quot; useOuterJava=&quot;true&quot; outerClassName=&quot;test.HelloWorld&quot; methodName=&quot;run&quot;/&gt;</pre>

<p>&nbsp; &nbsp; 比如上面的模型（XML）执行时并不需要执行它的run方法，它是由引擎直接执行的，引擎会根据它的属性定义执行Java类test.HelloWorld的run()方法。</p>

<h2>3.引擎常用API&nbsp;</h2>

<h4>3.1.初始化引擎</h4>

<p>&nbsp; &nbsp; 可以通过World类来初始化模型引擎，其中path参数是模型应用的目录，一般是引擎的工作目录，目录下可以包含类库、模型库和生成的临时文件等。</p>

<pre class="brush:java;">
import org.xmeta.World;

//Java项目可以使用当前目录作为引擎的工作目录
World world = World.getInstance();
world.init(&quot;.&quot;);</pre>

<h4>3.2.获取模型</h4>

<p>&nbsp; &nbsp; 可以通过模型的路径来获取一个模型.模型的路径规则基本同Java类名的规则，只是模型的路径还可以包含子节点的路径。如test.HelloWorldModel是描述者模型的路径。</p>

<pre class="brush:java;">
import org.xmeta.Thing;

//获得描述者模型
Thing thing = world.getThing(&quot;test.HelloWorldModel&quot;);</pre>

<h4>3.3.作为结构化数据时相关的API</h4>

<pre class="brush:java;">
//获取属性的值
Object value = thing.get(&quot;name&quot;);

//设置属性的值
thing.set(&quot;name&quot;, &quot;Hello World&quot;);

//获取属性的值并转为相应的类型，支持常见类型的转换
//一般是getX(Stirng name)方法，其中X是对应的类型
int age = thing.getInt(&quot;age&quot;);  
//注：属性未必需要在模型（XML)中定义，但序列化存储时未定义的属性不会被保存到XML中

//获取模型的子节点
List&lt;Thing&gt; childs = thing.getChilds();</pre>

<h4>3.4.动作和行为</h4>

<p>&nbsp; &nbsp; 把模型转化为动作执行。</p>

<pre class="brush:as3;">
import org.xmeta.Thing;
import org.xmeta.Aciton;
import org.xmeta.ActionContext;

//获取HelloWorldExample模型
Thing helloWorldExample = world.getThing(&quot;test.HelloWorldExample&quot;);

//转化为动作
Action helloWorldAction = helloWorldExample .getAction();

//执行动作
//动作和对象的行为执行时需要动作上下文(ActionContext)，动作上下文用于管理变量和线程状态等
helloWorldAction.run(new ActionContext());</pre>

<p>&nbsp; &nbsp; 把模型作为对象，执行它的行为</p>

<pre class="brush:java;">
import org.xmeta.Thing; 
import org.xmeta.ActionContext;

//获取HelloWorldExample模型
Thing helloWorldExample = world.getThing(&quot;test.HelloWorldExample&quot;);
//执行HelloWorldExample的run方法
helloWorldExample.doAction(&quot;run&quot;, new ActionContext());
</pre>

<p>&nbsp; &nbsp; 传参数的方法，动作执行时也适用。</p>

<pre class="brush:java;">
//传参，方法1，参数名+参数值，可以设置多个，参数名和参数值成对出现
Object result = thing.doAction(&quot;xxx&quot;, new ActionContext(), &quot;p1&quot;, p1Value,  &quot;p2&quot;, p2Value...);

//传参，方法2，通过ActionContext设置参数
ActionContext actionContext = new ActionContext();
actionContext.peek().put(&quot;p1&quot;, p1Value);
actionContext.peek().put(&quot;p2&quot;, p2Value);
......
Object result = thing.doAction(&quot;xxx&quot;, actionContext);
</pre>

<p>&nbsp; &nbsp; 动作和行为的区别，执行动作时模型不会把自己作为self变量传入到动作上下文中，而作为对象执行时会。因此动作执行时没有self变量（或self变量不是它自己），而执行对象的行为时self变量是对象模型自身。</p>

<p>&nbsp; &nbsp; 如下面代码中self变量，在执行HelloWorldExample模型对象的run行为时，self变量时HelloWorldExample模型自身。</p>

<pre class="brush:java;">
    public static void run(ActionContext actionContext){
        //模型实例，相当于Java的this变量的作用
        Thing self = actionContext.getObject(&quot;self&quot;);
 
        System.out.println(self.getString(&quot;message&quot;));
    }</pre>

<h4>3.5.面向对象相关的方法</h4>

<pre class="brush:java;">
//获取首要描述者(类）
Thing descriptor = thing.getDescriptor();

//获取所有描述者（类）
List&lt;Thing&gt; descriptors = thing.getDescriptors();

//获取事物名，相当于Java的object.getClass().getSimpleName()
String thingName = thing.getThingName();

//获取继承列表
List&lt;Thing&gt; extends = thing.getExtends();

//获取动作行为列表
List&lt;Thing&gt; actions = thing.getActionThings();</pre>

<p>&nbsp;&nbsp;</p>
#$@text#$@
sen_label
Dynamic Model
sdescriptors
xworker.swt.xworker.ThingRegistThing
sinheritDescription
false
sth_createIndex
true
sth_registThing
child|xworker.example.ExamplesIndex
sth_registMyChilds
false
sth_registDisabled
false
sth_noThingRegistViewer
false
sth_fileMonitor
false
Sen_description
#$@text#$@
<h1>Dynamic Model</h1>

<p>&nbsp; &nbsp; &nbsp;This paper introduces the basic concepts and methods of dynamic model programming.</p>

<h2>1.Introduction to dynamic model</h2>

<h3>1.1.Using structured data to represent objects</h3>

<p>&nbsp; &nbsp; Dynamic model uses structured data to represent objects, so objects are data in the system, which can be represented by XML.</p>

<p>&nbsp; &nbsp; For example, the following XML is a dynamic model program.</p>

<pre class="brush:xml;">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Shell name=&quot;shell&quot; descriptors=&quot;xworker.swt.widgets.Shell&quot; text=&quot;TestShell&quot;&gt;
    &lt;FillLayout name=&quot;FillLayout&quot;&gt;&lt;/FillLayout&gt;
    &lt;Browser name=&quot;Browser&quot; url=&quot;https://www.xworker.org&quot;&gt;&lt;/Browser&gt;
    &lt;GroovyAction name=&quot;init&quot;  code=&quot;println &amp;quot;Hello World!&amp;quot;;&quot;&gt;&lt;/GroovyAction&gt;
&lt;/Shell&gt;</pre>

<h3>1.2.Dynamic object oriented programming method</h3>

<p>&nbsp; &nbsp; In the dynamic model, classes are also common objects, and objects are structured data, so classes and objects can be created and modified at any time when the system is running.</p>

<h2>2.Principle of dynamic model</h2>

<h3>2.1.The role of data</h3>

<p>&nbsp; &nbsp; A data is used according to its role. Dynamic model realizes object-oriented programming by giving data different roles.</p>

<h3>2.2.Principle</h3>

<p>&nbsp; &nbsp; The core of the principle of dynamic model is to assume first and then realize. In short, it is assumed that data can be used to represent all kinds of things, for example, data can represent actions that can be run (acting on methods and functions), and then use these assumptions to define concepts such as objects, and finally how to execute methods.</p>

<h4>2.2.1.Models and things</h4>

<p>&nbsp; &nbsp; Dynamic models think that data can be used to represent all kinds of things, so sometimes we call these data models or things.</p>

<p>&nbsp; &nbsp; In a dynamic model, data can be represented by XML, and an XML node is composed of attributes and sub nodes, so a model or thing is composed of attributes and sub nodes (sub models or sub things).</p>

<h4>2.2.2.Action</h4>

<p>&nbsp; &nbsp; Dynamic model considers that any model can be transformed into actions,&nbsp;in which action&nbsp;can be executed, and actions&nbsp;are equivalent to methods and functions.</p>

<h4>2.2.3.Object</h4>

<p>&nbsp; &nbsp; Since a model can contain attributes and sub models (the definition of 2.2.1.) and any model can execute (the assumption of 2.2.2), some sub nodes of a model can be regarded as its behavior, so a model can be regarded as an object.</p>

<p>&nbsp; &nbsp; Actions are equivalent to methods and functions. When an action belongs to an object and the object can call the action, the action can be regarded as the behavior of the object.</p>

<h4>2.2.4.Descriptor</h4>

<p>&nbsp; &nbsp; A descriptor is a model used to describe a model. A descriptor can also be regarded as the&nbsp;class of a model, which is used to describe the structure and behavior of a model. In a dynamic model, the descriptor of a model can be any model, and the model inherits the behavior of the descriptor.</p>

<h4>2.2.5.Extend</h4>

<p>&nbsp; &nbsp; In a dynamic model, a model can inherit any model except itself, thus inheriting the behavior of the inherited model.</p>

<h3>2.3.Object-oriented</h3>

<p>&nbsp; &nbsp; In the dynamic model, by assigning various roles to the data, the dynamic model actually realizes the object-oriented programming method.</p>

<h2>3.Realization of dynamic model</h2>

<p>&nbsp; &nbsp; The core of implementing dynamic model programming is how to explain and execute a model.</p>

<ol>
	<li>In 2.2.2. Above, it is assumed that any model can be transformed into actions to execute. The specific method is to take the model as the object and execute the run method of the object.</li>
	<li>The run method of the model is still the model (see 2.2.3, using the child nodes of the model to define the behavior of the model), so execute the run method and go back to step 1.</li>
	<li>The above is a recursive method. If you want the recursion to terminate, some models are executed directly by the engine.</li>
</ol>

<p>&nbsp; &nbsp; The above is how to execute a model. For example, xworker&#39;s dynamic model engine is implemented in Java, and the model named JavaAction is directly executed by the engine, that is, the engine directly interprets and executes the JavaAction instead of executing its run method.</p>

<pre class="brush:xml;">
&lt;JavaAction name=&quot;run&quot; useOuterJava=&quot;true&quot; outerClassName=&quot;test.HelloWorld&quot; methodName=&quot;run&quot;/&gt;</pre>

<p>&nbsp; &nbsp; For example, when the above model (XML) is executed, it does not need to execute its run method. It is executed directly by the engine, and the engine will execute Java classes according to its attribute definition test.HelloWorld The run () method of.</p>

<h2>4.Common API of engine&nbsp; &nbsp;</h2>

<h4>4.1.Initialize engine</h4>

<p>&nbsp; &nbsp; The model engine can be initialized through the world class. The path parameter is the directory of the model application, which is generally the working directory of the engine. The directory can contain class library, model library and generated temporary files.</p>

<pre class="brush:java;">
import org.xmeta.World;

World world = World.getInstance();
world.init(&quot;.&quot;);</pre>

<h4>4.2.Get model</h4>

<p>&nbsp; &nbsp; You can get a model through the path of the model. The path rules of the model are basically the same as those of the Java class name, but the path of the model can also contain the path of the child node. as test.HelloWorldModel Is the path to the descriptor model.</p>

<pre class="brush:java;">
import org.xmeta.Thing;

//Get descriptor model
Thing thing = world.getThing(&quot;test.HelloWorldModel&quot;);</pre>

<h4>4.3.As an API related to structured data</h4>

<pre class="brush:java;">
//Gets the value of a property
Object value = thing.get(&quot;name&quot;);

//Sets the value of a property
thing.set(&quot;name&quot;, &quot;Hello World&quot;);

//Get the value of a property and convert it to the corresponding type, support the conversion of common types
//The general method is geTx (Stirng name), where x is the corresponding type
int age = thing.getInt(&quot;age&quot;);  

//Gets the child nodes
List&lt;Thing&gt; childs = thing.getChilds();</pre>

<h4>4.4.Actions and behaviors</h4>

<p>&nbsp; &nbsp; Convert model to action</p>

<pre class="brush:as3;">
import org.xmeta.Thing;
import org.xmeta.Aciton;
import org.xmeta.ActionContext;

//Get the HelloWorldExample model
Thing helloWorldExample = world.getThing(&quot;test.HelloWorldExample&quot;);

//Convert to action, compare with Java, action is similar to static method
Action helloWorldAction = helloWorldExample .getAction();

//Execution action
//ActionContext is needed when actions and objects are executed. Action context is used to manage variables and thread states
helloWorldAction.run(new ActionContext());</pre>

<p>&nbsp; &nbsp; Take the model as an object and execute its behavior</p>

<pre class="brush:java;">
import org.xmeta.Thing; 
import org.xmeta.ActionContext;

//Get the HelloWorldExample model
Thing helloWorldExample = world.getThing(&quot;test.HelloWorldExample&quot;);
//Execute the run method of HelloWorld example.
//When executing an object&#39;s behavior, the object itself will be put into the action context with the variable name self (equivalent to this variable), and the action can access the object model through the self variable.
helloWorldExample.doAction(&quot;run&quot;, new ActionContext());
</pre>

<p>&nbsp; &nbsp; The method of transferring parameters is also applicable to action execution.</p>

<pre class="brush:java;">
//Pass parameter, method 1, parameter name + parameter value, can set multiple, parameter name and parameter value appear in pairs
Object result = thing.doAction(&quot;xxx&quot;, new ActionContext(), &quot;p1&quot;, p1Value,  &quot;p2&quot;, p2Value...);

//Pass parameters, method 2, set parameters through actioncontext
ActionContext actionContext = new ActionContext();
actionContext.peek().put(&quot;p1&quot;, p1Value);
actionContext.peek().put(&quot;p2&quot;, p2Value);
......
Object result = thing.doAction(&quot;xxx&quot;, actionContext);
</pre>

<p>&nbsp; &nbsp;The difference between action and behavior is that when an action is executed, the model does not pass itself into the action context as a self variable, but it does when it is executed as an object. Therefore, when an action is executed, there is no self variable (or the self variable is not itself), while when an object&#39;s behavior is executed, the self variable is the object model itself.</p>

<p>&nbsp; &nbsp; For example, in the following code, the self variable is the HelloWorld example model itself when executing the run behavior of the HelloWorld example model object.</p>

<pre class="brush:java;">
    public static void run(ActionContext actionContext){
        //Model instance, equivalent to the role of Java&#39;s this variable
        Thing self = actionContext.getObject(&quot;self&quot;);
 
        System.out.println(self.getString(&quot;message&quot;));
    }</pre>

<h4>4.5Object oriented method</h4>

<pre class="brush:java;">
//Get the primary descriptor (class)
Thing descriptor = thing.getDescriptor();

//Get all descriptors (classes)
List&lt;Thing&gt; descriptors = thing.getDescriptors();

//Get the object name, which is equivalent to Java object.getClass().getSimpleName()
String thingName = thing.getThingName();

//Get inheritance list
List&lt;Thing&gt; extends = thing.getExtends();

//Get action list
List&lt;Thing&gt; actions = thing.getActionThings();</pre>

<p>&nbsp;&nbsp;</p>
#$@text#$@
sth_mark
false
sth_registQueryOnlySelf
false
