^1382925898649
@xworker.lang.function.FunctionFunction
sname
FunctionFunction
slabel
FunctionFunction
sdescriptors
xworker.lang.MetaDescriptor3
sextends
xworker.lang.function.Function
smany
true
seditCols
2
sinitialization
false
smodifier
public
sinheritDescription
false
Sdescription
#$@text#$@
<p>用函数定义的函数，即函数的doFunction将执行另外一个函数，而当前函数的参数的值将会传入到被调用的函数里。</p>

<p><strong>参数定义规范</strong></p>

<p>函数定义的参数子函数可以通过GetParameter函数获取。</p>
#$@text#$@
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
@xworker.lang.function.FunctionFunction/@actions
sname
actions
sdescriptors
xworker.lang.MetaDescriptor3/@actions
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
@xworker.lang.function.FunctionFunction/@actions/@foFunction
sname
doFunction
sisSynchronized
false
sthrowException
true
suseOtherAction
false
suseOuterJava
true
souterClassName
xworker.lang.function.FunctionActions
smethodName
runFunctionFunction
sdisableGlobalContext
false
sattributeTemplate
false
sinitBreakPoint
false
ssuccessBreakPoint
false
sexceptionBreakPoint
false
seditBreakPoint
false
sinterpretationType
Action
svarScope
Global
screateLocalVarScope
false
ssaveReturn
false
sdescriptors
xworker.lang.actions.Actions/@JavaAction
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
@xworker.lang.function.FunctionFunction/@Function
sname
Function
sdescriptors
xworker.lang.MetaDescriptor3/@thing
smany
false
seditCols
2
sinitialization
false
smodifier
public
sinheritDescription
false
sdescription
<p>具体的要调用的函数放到这个节点下，只有第一个子节点生效。</p>
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
@xworker.lang.function.FunctionFunction/@name
sname
name
sshowLabel
true
sreadOnly
false
sinheritDescription
false
svalidateAllowBlank
true
LvalidateOnBlur
true
LallowDecimals
true
LallowNegative
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
@xworker.lang.function.FunctionFunction/@label
sname
label
sshowLabel
true
sreadOnly
false
sinheritDescription
false
svalidateAllowBlank
true
LvalidateOnBlur
true
LallowDecimals
true
LallowNegative
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
@xworker.lang.function.FunctionFunction/@uiHandler
sname
uiHandlerId
sinputtype
openWindow
sshowLabel
true
ssize
60
sinputattrs
xworker.ui.editors.attribute.UIHandlerIDSelectShell
sreadOnly
false
sinheritDescription
false
Sdescription
#$@text#$@
<p>如果函数的参数为完全设置或者校验失败，那么使用哪一个UIHanlder打开，为空表示默认使用默认的UIHandler打开。</p>

<p><strong>UIHandler的注意事项：</strong></p>

<p>&nbsp;&nbsp;&nbsp; UIHandler处理的请求是UIRequest，而UIRequest.getRequestMessage()是函数的请求（FunctionRequest）。</p>
#$@text#$@
svalidateAllowBlank
true
LvalidateOnBlur
true
LallowDecimals
true
LallowNegative
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
@xworker.lang.function.FunctionFunction/@selfCallback
sname
selfCallback
sinputtype
truefalse
sshowLabel
true
sreadOnly
false
sdefault
true
sinheritDescription
false
Sdescription
#$@text#$@
<p>如果为true，那么本函数自己执行回调而不是由函数解释器执行回调。</p>

<p>当一个函数执行完毕后函数解释器会立即执行回调并返回到上级函数，但是对UI函数来说函数的执行完毕才是打开UI的时候，由于UI函数通常不会阻塞线程等待UI的交互完毕，所以UI函数执行完毕时不是真的完成，而是要等到UI结束时才完成。</p>

<p>通过设置设置selfCallback=true可以解决UI函数的问题，在UI结束后函数自行调用callack返回上级函数。</p>
#$@text#$@
svalidateAllowBlank
true
LvalidateOnBlur
true
LallowDecimals
true
LallowNegative
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
sth_createIndex
false
sregistMyChilds
false
sth_mark
false
