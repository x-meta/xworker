<?xml version="1.0" encoding="utf-8"?>

<QuickFunction name="DynamicModel" descriptors="xworker.swt.xworker.ThingRegistThing" label="动态模型"
     type="thingDesc" group="dynamicModel" groupDescriptor="true" icon="icons/html.png"
     th_sortWeight="-9000" simpleBrowser="true" en_label="Dynamic Model" th_createIndex="true"
     th_registThing="child|xworker.example.ExamplesIndex">
    <description><![CDATA[<h1>动态模型</h1>

<p>&nbsp; &nbsp; 这里讲述动态模型的基本概念，关于如何创建和编辑模型，请参看教程。</p>

<h2>1.面向对象编程方法</h2>

<p>&nbsp; &nbsp; 动态模型是一种面向对象的编程方法，它使用模型来表示对象，而模型是树形结构的数据可以用XML来表示。&nbsp;</p>

<p>&nbsp; &nbsp; 比如下面的XML就是一个模型。</p>

<pre class="brush:xml;">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   
&lt;Shell name=&quot;HelloWorld&quot; descriptors=&quot;xworker.swt.widgets.Shell&quot; text=&quot;Hello World&quot; RESIZE=&quot;true&quot;
     width=&quot;800&quot; height=&quot;600&quot;&gt;
    &lt;FillLayout name=&quot;FillLayout&quot;&gt;&lt;/FillLayout&gt;
    &lt;Browser name=&quot;Browser&quot; url=&quot;https://www.xworker.org&quot; WEBKIT=&quot;true&quot;&gt;&lt;/Browser&gt;
&lt;/Shell</pre>

<h3>1.1.每一个模型节点都是独立的对象</h3>

<p>&nbsp; &nbsp; 模型是树形结构的数据，因此一个模型可以有子模型（子节点），在动态模型里每一个节点都被当成独立的对象。</p>

<p>&nbsp; &nbsp; 比如在上面的XML代码里，＜Shell .../&gt; 、＜FillLayout .../&gt;和&lt;Browser .../&gt;等节点都是独立的对象。</p>

<h2>2.模型的基本概念</h2>

<p>&nbsp; &nbsp; 模型也是对象，因此也可以理解为动态模型中对象的基本概念。</p>

<h3>2.1.模型的结构</h3>

<p>&nbsp; &nbsp; &nbsp;一个模型可以包含属性和子节点，见上面XML的例子。</p>

<h3>2.2.动作</h3>

<p>&nbsp; &nbsp; 动态模型认为任何一个模型都是可以转化为动作，而动作是可执行的。</p>

<p>&nbsp; &nbsp; 动态模型中的动作相当于编程语言中的函数和方法。</p>

<pre class="brush:groovy;">
import org.xmeta.Action;
import org.xmeta.Thing;
import org.xmeta.ActionContext;

//Thing代表模型
Thing thing = new Thing();

//Thing的getAction()方法用于转换模型到动作
Action action = thing.getAction();

//动作可以执行，ActionContext是动作的执行上下文
action.run(new ActionContext());</pre>

<h3>2.3.模型的行为</h3>

<p>&nbsp; &nbsp; 因为任何模型都可以转化为动作，而动作是可执行的，因此可以把一个模型的某些子节点定义为它的行为。</p>

<p>&nbsp; &nbsp; XWorker所使用的动态模型引擎规定一个模型下的第一个节点名为actions的子节点下的所有子节点是模型的行为的定义。</p>

<pre class="brush:xml;">
&lt;thing name=&quot;Person&quot;&gt;
    &lt;actions&gt;
        &lt;JavaAction name=&quot;sayHello&quot;.../&gt;
    &lt;/actions&gt;
&lt;/thing&gt;</pre>

<p>&nbsp; &nbsp; 在上面的XML代码里，节点actions下的JavaAction是一个行为的定义，即&lt;thing name=&quot;Person&quot;/&gt;模型有一个sayHello行为。</p>

<pre class="brush:groovy;">
import org.xmeta.Thing;
import org.xmeta.World;
import org.xmeta.ActionContext;

//获取&lt;thing name=&quot;Person&quot;/&gt;模型，&lt;PersonPath&gt;是这个模型的实际路径。
//这里是示意代码，并没有具体的模型
Thing person = World.getIntance().getThing(&quot;&lt;PersonPath&gt;&quot;);

//执行sayHello方法
person.doAction(&quot;sayHello&quot;, new ActionContext());</pre>

<h3>2.4.描述者（类）</h3>

<p>&nbsp; &nbsp; 动态模型规定一个模型可以使用任意模型和任意多个模型作为它的描述者，描述者的作用是可以描述一个模型的结构和行为，因此模型继承描述者的行为。</p>

<p>&nbsp; &nbsp; 描述者的作用等价于面向对象中的类的作用，因此描述者也是类。</p>

<pre class="brush:xml;">
&lt;Person name=&quot;Zhangsan&quot; descriptors=&quot;Person&quot;/&gt;</pre>

<p>&nbsp; &nbsp; 描述者一般在写在模型的descriptors属性中，比如在上面代码中，Zhangsan这个模型以Person这个模型模型作为它的描述者（类）。</p>

<h3>2.5.继承</h3>

<p>&nbsp; &nbsp; &nbsp;动态模型规定一个模型可以继承除自身外的其它任意和任意个模型，在继承模型时，模型继承被继承模型的行为，但不继承属性和子节点。</p>

<pre class="brush:xml;">
&lt;thing name=&quot;Person&quot; extends=&quot;Animal&quot;/&gt;</pre>

<p>&nbsp; &nbsp; 继承一般写在模型的extends属性中，如上面的模型表示Person继承Animal。</p>

<h3>2.6.面向对象</h3>

<p>&nbsp; &nbsp; 以上是如何使用模型(XML)来表示对象的方法，实际上动态模型几乎具有面向对象的全部核心功能。</p>

<h4>2.6.1.方法的重写和多态</h4>

<p>&nbsp; &nbsp; 由于一个模型行为可以在自身定义，也可以继承于描述者（类）或继承的其它模型，因此同一个名字的行为可能在多个地方都定义了，这就存在该使用哪一个行为的问题了。在动态模型里，获取行为的优先顺序是模型自身&gt;描述者(类）&gt;继承。</p>

<p>&nbsp; &nbsp; 动态模型中寻找行为的优先顺序实际实现了面向对象中方法的重写和多态等功能。比如Person继承了Animal，那么在Person中定义了Animal中同名的行为，那么就等价于重写了Animal的方法。</p>

<h4>2.6.2.描述者（类）的定义的作用</h4>

<p>&nbsp; &nbsp; 在面向对象中，如果类Animal定义了一个age属性，而类Person继承了Aniaml，那么类Person的对象实例如Zhangsan就有age属性。描述者（类）的定义作用同样在动态模型中也有体现，具体是创建模型的部分，可以参看后续的编辑模型的教程。</p>

<h2>3.动态模型的实现原理</h2>

<p>&nbsp; &nbsp; 了解的模型的基本概念后，可以发现动态模型实际上是一个相对抽象的编程方法，要想实现动态模型编程，还需把模型变成可执行的程序。</p>

<p>&nbsp; &nbsp; 运行一个模型的核心是如何运行一个对象（模型），具体是如何运行一个对象的行为方法，动态模型是通过递归实现的。</p>

<ol>
	<li>要运行一个对象，默认执行它的名字为run的行为。</li>
	<li>而名字为run的行为还是对象（行为一般通过对象的子节点来定义，而对象的子节点还是对象）。</li>
	<li>要执行run这个对象，重复1，这是一个递归操作，若要让递归能够终止，那么某些对象是由引擎直接解释执行的。</li>
</ol>

<p>&nbsp; &nbsp; 以上就是如何运行一个对象的方法，XWorker是使用Java编写的，它规定类型为JavaAction的模型对象是由引擎直接解释执行的。</p>

<h2>&nbsp;</h2>
]]></description>
</QuickFunction>