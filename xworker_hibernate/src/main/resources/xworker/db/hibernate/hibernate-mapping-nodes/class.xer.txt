@xworker.db.hibernate.hibernate-mapping-nodes.class
sname
class
slabel
class
sdescriptors
xworker.lang.MetaDescriptor3
smany
true
seditCols
2
sinitialization
false
sdescription
你可以使用class元素来定义一个持久化类.。<br /><br />若指明的持久化类实际上是一个接口，这也是完全可以接受的。之后你可以用<subclass></subclass>来指定该接口的实际实现类。 你可以持久化任何static（静态的）内部类。 你应该使用标准的类名格式来指定类名，比如：Foo$Bar。 对Hibernate映射来说视图和表是没有区别的，这是因为它们在数据层都是透明的（ 注意：一些数据库不支持视图属性，特别是更新的时候）。<br /><br />有时你想使用视图，但却不能在数据库 中创建它（例如：在遗留的schema中）。这样的话，你可以映射一个不可变的（immutable）并且是 只读的实体到一个给定的SQL子查询表达式。定义这个实体用到的表为同步（synchronize），确保自动刷新（auto-flush）正确执行， 并且依赖原实体的查询不会返回过期数据。<subselect></subselect>在属性元素 和一个嵌套映射元素中都可见。
sid
class
@xworker.db.hibernate.hibernate-mapping-nodes.class/@name
sname
name
slabel
name
sdescription
持久化类（或者接口）的Java全限定名。 如果这个属性不存在，Hibernate将假定这是一个非POJO的实体映射。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
name
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@table
sname
table
slabel
table
sdescription
对应的数据库表名。默认是类的非全限定名。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
table
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@entity-name
sname
entity-name
slabel
entity-name
sdescription
Hibernate3允许一个类进行多次映射（ 默认情况是映射到不同的表），并且允许使用Maps或XML代替Java层次的实体映射 （也就是实现动态领域模型，不用写持久化类－译注）。 更多信息请看<a title="5.4.&nbsp;动态模型(Dynamic models)" href="http://www.huihoo.com/framework/hibernate/reference-v3_zh-cn/persistent-classes.html#persistent-classes-dynamicmodels" tppabs="http://www.hibernate.org/hib_docs/v3/reference/zh-cn/html/persistent-classes.html#persistent-classes-dynamicmodels">第&nbsp;5.4&nbsp;节 &ldquo;动态模型(Dynamic models)&rdquo;</a> and <a title="第&nbsp;19&nbsp;章&nbsp;XML映射" href="http://www.huihoo.com/framework/hibernate/reference-v3_zh-cn/xml.html" tppabs="http://www.hibernate.org/hib_docs/v3/reference/zh-cn/html/xml.html">第&nbsp;19&nbsp;章 <em>XML映射</em></a>。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
entity-name
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@catalog
sname
catalog
slabel
catalog
sdescription
覆盖在根<hibernate-mapping>元素中指定的catalog名字。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
catalog
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@select-before-update
sname
select-before-update
slabel
select-before-update
sinputtype
select
sdefault
false
Sdescription
#$@text#$@
指定Hibernate除非确定对象真正被修改了（如果该值为true－译注），否则不会执行SQL UPDATE操作。在特定场合（实际上，它只在一个瞬时对象（transient object）关联到一个 新的session中时执行的update()中生效），这说明Hibernate会在UPDATE 之前执行一次额外的SQL SELECT操作，来决定是否应该执行 UPDATE。

使用select-before-update通常会降低性能。如果你重新连接一个脱管（detache）对象实例 到一个Session中时，它可以防止数据库不必要的触发update。 这就很有用了。
#$@text#$@
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
select-before-update
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@select-before-update/@true
sname
true
slabel
true
svalue
true
sid
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@select-before-update/@false
sname
false
slabel
false
svalue
false
sid
false
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@persister
sname
persister
slabel
persister
sdescription
指定一个定制的ClassPersister。 persister属性可以让你定制这个类使用的持久化策略。 <br /><br />你可以指定你自己实现 org.hibernate.persister.EntityPersister的子类，你甚至可以完全从头开始编写一个 org.hibernate.persister.ClassPersister接口的实现， 比如是用储存过程调用、序列化到文件或者LDAP数据库来实现。 参阅org.hibernate.test.CustomPersister，这是一个简单的例子 （&ldquo;持久化&rdquo;到一个Hashtable）。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
persister
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@polymorphism
sname
polymorphism
slabel
polymorphism
sinputtype
select
sdefault
implicit
sdescription
界定是隐式还是显式的使用多态查询（这只在Hibernate的具体表继承策略中用到－译注）。<br /><br /> Implicit (隐式)的多态是指，如果查询时给出的是任何超类、该类实现的接口或者该类的 名字，都会返回这个类的实例；如果查询中给出的是子类的名字，则会返回子类的实例。 Explicit （显式）的多态是指，只有在查询时给出明确的该类名字时才会返回这个类的实例； 同时只有在这个<class></class>的定义中作为<subclass></subclass> 或者<joined-subclass></joined-subclass>出现的子类，才会可能返回。 在大多数情况下，默认的polymorphism=&quot;implicit&quot;都是合适的。 显式的多态在有两个不同的类映射到同一个表的时候很有用。（允许一个&ldquo;轻型&rdquo;的类，只包含部分表字段）。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
polymorphism
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@polymorphism/@implicit
sname
implicit
slabel
implicit
svalue
implicit
sid
implicit
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@polymorphism/@explicit
sname
explicit
slabel
explicit
svalue
explicit
sid
explicit
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@discriminator-value
sname
discriminator-value
slabel
discriminator-value
sdescription
一个用于区分不同的子类的值，在多态行为时使用。它可以接受的值包括 null 和 not null。 默认和类名一样
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
discriminator-value
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@dynamic-update
sname
dynamic-update
slabel
dynamic-update
sinputtype
select
sdefault
false
sdescription
指定用于UPDATE 的SQL将会在运行时动态生成，并且只更新那些改变过的字段。 <br /><br />请注意dynamic-update和dynamic-insert的设置并不会继承到子类， 所以在<subclass></subclass>或者<joined-subclass></joined-subclass>元素中可能 需要再次设置。这些设置是否能够提高效率要视情形而定。请用你的智慧决定是否使用。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
dynamic-update
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@dynamic-update/@true
sname
true
slabel
true
svalue
true
sid
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@dynamic-update/@false
sname
false
slabel
false
svalue
false
sid
false
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@dynamic-insert
sname
dynamic-insert
slabel
dynamic-insert
sinputtype
select
sdefault
false
sdescription
指定用于INSERT的 SQL 将会在运行时动态生成，并且只包含那些非空值字段。 <br /><br />请注意dynamic-update和dynamic-insert的设置并不会继承到子类， 所以在<subclass></subclass>或者<joined-subclass></joined-subclass>元素中可能 需要再次设置。这些设置是否能够提高效率要视情形而定。请用你的智慧决定是否使用。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
dynamic-insert
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@dynamic-insert/@true
sname
true
slabel
true
svalue
true
sid
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@dynamic-insert/@false
sname
false
slabel
false
svalue
false
sid
false
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@rowid
sname
rowid
slabel
rowid
sdescription
Hibernate可以使用数据库支持的所谓的ROWIDs，例如： Oracle数据库，如果你设置这个可选的rowid， Hibernate可以使用额外的字段rowid实现快速更新。ROWID是这个功能实现的重点， 它代表了一个存储元组（tuple）的物理位置。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
rowid
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@optimistic-lock
sname
optimistic-lock
slabel
optimistic-lock
sinputtype
select
sdefault
version
sdescription
决定乐观锁定的策略。 <br /><br />如果你打开了dynamic-update，你可以选择几种乐观锁定的策略： version（版本检查） 检查version/timestamp字段 all（全部） 检查全部字段 dirty（脏检查）只检察修改过的字段 none（不检查）不使用乐观锁定 我们非常强烈建议你在Hibernate中使用version/timestamp字段来进行乐观锁定。 对性能来说，这是最好的选择，并且这也是唯一能够处理在session外进行操作的策略（例如： 在使用Session.merge()的时候）。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
optimistic-lock
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@optimistic-lock/@none
sname
none
slabel
none
svalue
none
sid
none
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@optimistic-lock/@version
sname
version
slabel
version
svalue
version
sid
version
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@optimistic-lock/@dirty
sname
dirty
slabel
dirty
svalue
dirty
sid
dirty
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@optimistic-lock/@all
sname
all
slabel
all
svalue
all
sid
all
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@where
sname
where
slabel
where
sinputtype
textarea
scolspan
2
sinputattrs
codeName= codeType= wrap=false fillBoth=true cols= rows=80
sreadOnly
false
sinheritDescription
false
sdescription
指定一个附加的SQLWHERE 条件， 在抓取这个类的对象时会一直增加这个条件。
svalidateAllowBlank
true
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
where
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@subselect
sname
subselect
slabel
subselect
sinputtype
textarea
scolspan
2
sinputattrs
codeName= codeType= wrap=false fillBoth=true cols= rows=80
sreadOnly
false
sinheritDescription
false
sdescription
它将一个不可变（immutable）并且只读的实体映射到一个数据库的 子查询中。它用于实现一个视图代替一张基本表，但是最好不要这样做。更多的介绍请看下面内容。
svalidateAllowBlank
true
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
subselect
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@schema
sname
schema
slabel
schema
sdescription
覆盖在根<hibernate-mapping>元素中指定的schema名字。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
schema
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@node
sname
node
slabel
node
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
node
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@mutable
sname
mutable
slabel
mutable
sinputtype
select
sdefault
true
sdescription
表明该类的实例是可变的或者可变的。 <br /><br />不可变类，mutable=&quot;false&quot;不可以被应用程序更新或者删除。 这可以让Hibernate做一些小小的性能优化。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
mutable
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@mutable/@true
sname
true
slabel
true
svalue
true
sid
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@mutable/@false
sname
false
slabel
false
svalue
false
sid
false
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@abstract
sname
abstract
slabel
abstract
sinputtype
select
sdescription
用于在<union-subclass>的继承结构 （hierarchies）中标识抽象超类。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
abstract
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@abstract/@true
sname
true
slabel
true
svalue
true
sid
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@abstract/@false
sname
false
slabel
false
svalue
false
sid
false
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@lazy
sname
lazy
slabel
lazy
sinputtype
select
sdescription
通过设置lazy=&quot;false&quot;， 所有的延迟加载（Lazy fetching）功能将未被激活（disabled）。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
lazy
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@lazy/@true
sname
true
slabel
true
svalue
true
sid
true
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@lazy/@false
sname
false
slabel
false
svalue
false
sid
false
sdescriptors
xworker.lang.MetaDescriptor3/@attribute/@value
@xworker.db.hibernate.hibernate-mapping-nodes.class/@proxy
sname
proxy
slabel
proxy
sdescription
指定一个接口，在延迟装载时作为代理使用。 你可以在这里使用该类自己的名字。 <br /><br />可选的proxy属性允许延迟加载类的持久化实例。 Hibernate开始会返回实现了这个命名接口的CGLIB代理。当代理的某个方法被实际调用的时候， 真实的持久化对象才会被装载。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
proxy
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@check
sname
check
slabel
check
sinputtype
textarea
scolspan
2
sinputattrs
rows="3" cols="60" wrap="off"
sdescription
这是一个SQL表达式， 用于为自动生成的schema添加多行（multi-row）约束检查。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
check
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@batch-size
sname
batch-size
slabel
batch-size
sdescription
指定一个用于 根据标识符（identifier）抓取实例时使用的"batch size"（批次抓取数量）。
LvalidateOnBlur
false
LallowDecimals
false
LallowNegative
false
sid
batch-size
sdescriptors
xworker.lang.MetaDescriptor3/@attribute
@xworker.db.hibernate.hibernate-mapping-nodes.class/@meta
sname
meta
slabel
meta
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.meta
smany
true
seditCols
2
sinitialization
false
sid
meta
@xworker.db.hibernate.hibernate-mapping-nodes.class/@subselect1
sname
subselect
slabel
subselect
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.subselect
smany
true
seditCols
2
sinitialization
false
sid
subselect1
@xworker.db.hibernate.hibernate-mapping-nodes.class/@cache
sname
cache
slabel
cache
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.cache
smany
true
seditCols
2
sinitialization
false
sdescription
Hibernate的<tt class="literal"><font face="新宋体">Session</font></tt>在事务级别进行持久化数据的缓存操作。 当然，也有可能分别为每个类（或集合)，配置集群、或JVM级别(<tt class="literal"><font face="新宋体">SessionFactory级别</font></tt>)的缓存。 你甚至可以为之插入一个集群的缓存。注意，缓存永远不知道其他应用程序对持久化仓库（数据库）可能进行的修改 （即使可以将缓存数据设定为定期失效）。
sid
cache
@xworker.db.hibernate.hibernate-mapping-nodes.class/@synchronize
sname
synchronize
slabel
synchronize
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.synchronize
smany
true
seditCols
2
sinitialization
false
sid
synchronize
@xworker.db.hibernate.hibernate-mapping-nodes.class/@comment
sname
comment
slabel
comment
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.comment
smany
true
seditCols
2
sinitialization
false
sid
comment
@xworker.db.hibernate.hibernate-mapping-nodes.class/@tuplizer
sname
tuplizer
slabel
tuplizer
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.tuplizer
smany
true
seditCols
2
sinitialization
false
sid
tuplizer
@xworker.db.hibernate.hibernate-mapping-nodes.class/@id
sname
id
slabel
id
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.id
smany
true
seditCols
2
sinitialization
false
sid
id
@xworker.db.hibernate.hibernate-mapping-nodes.class/@composite-id
sname
composite-id
slabel
composite-id
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.composite-id
smany
true
seditCols
2
sinitialization
false
sdescription
如果表使用联合主键，你可以映射类的多个属性为标识符属性。 <tt class="literal"><font face="新宋体"><composite-id></composite-id></font></tt>元素接受<tt class="literal"><font face="新宋体"><key-property></key-property></font></tt> 属性映射和<tt class="literal"><font face="新宋体"><key-many-to-one></key-many-to-one></font></tt>属性映射作为子元素。<br /><br />你的持久化类<span class="emphasis"><em>必须</em></span>重载<tt class="literal"><font face="新宋体">equals()</font></tt>和 <tt class="literal"><font face="新宋体">hashCode()</font></tt>方法，来实现组合的标识符的相等判断。 实现<tt class="literal"><font face="新宋体">Serializable</font></tt>接口也是必须的。<br /><br />不幸的是，这种组合关键字的方法意味着一个持久化类是它自己的标识。除了对象自己之外， 没有什么方便的&ldquo;把手&rdquo;可用。你必须自己初始化持久化类的实例，在使用组合关键字<tt class="literal"><font face="新宋体">load()</font></tt> 持久化状态之前，必须填充他的联合属性。我们会在<a title="9.4.&nbsp;组件作为联合标识符(Components as composite identifiers)" tppabs="http://www.hibernate.org/hib_docs/v3/reference/zh-cn/html/components.html#components-compositeid" href="http://www.huihoo.com/framework/hibernate/reference-v3_zh-cn/components.html#components-compositeid">第&nbsp;9.4&nbsp;节 &ldquo;组件作为联合标识符(Components as composite identifiers)&rdquo;</a>章中说明一种 更加便捷的方法，把联合标识实现为一个独立的类，下面描述的属性只对这种备用方法有效:
sid
composite-id
@xworker.db.hibernate.hibernate-mapping-nodes.class/@discriminator
sname
discriminator
slabel
discriminator
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.discriminator
smany
true
seditCols
2
sinitialization
false
sdescription
在&quot;一棵对象继承树对应一个表&quot;的策略中,<tt class="literal"><font face="新宋体">&lt;discriminator&gt;</font></tt>元素是必需的, 它定义了表的鉴别器字段。鉴别器字段包含标志值，用于告知持久化层应该为某个特定的行创建哪一个子类的实例。 如下这些受到限制的类型可以使用： <tt class="literal"><font face="新宋体">string</font></tt>, <tt class="literal"><font face="新宋体">character</font></tt>, <tt class="literal"><font face="新宋体">integer</font></tt>, <tt class="literal"><font face="新宋体">byte</font></tt>, <tt class="literal"><font face="新宋体">short</font></tt>, <tt class="literal"><font face="新宋体">boolean</font></tt>, <tt class="literal"><font face="新宋体">yes_no</font></tt>, <tt class="literal"><font face="新宋体">true_false</font></tt>. <br /><br />鉴别器字段的实际值是根据<tt class="literal"><font face="新宋体">&lt;class&gt;</font></tt>和<tt class="literal"><font face="新宋体">&lt;subclass&gt;</font></tt>元素中 的<tt class="literal"><font face="新宋体">discriminator-value</font></tt>属性得来的。
sid
discriminator
@xworker.db.hibernate.hibernate-mapping-nodes.class/@natural-id
sname
natural-id
slabel
natural-id
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.natural-id
smany
true
seditCols
2
sinitialization
false
sid
natural-id
@xworker.db.hibernate.hibernate-mapping-nodes.class/@version
sname
version
slabel
version
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.version
smany
true
seditCols
2
sinitialization
false
sdescription
<font face="新宋体">&lt;version&gt;</font>元素是可选的，表明表中包含附带版本信息的数据。 这在你准备使用<span class="emphasis"><em> 长事务（long transactions）</em></span>的时候特别有用。
sid
version
@xworker.db.hibernate.hibernate-mapping-nodes.class/@timestamp
sname
timestamp
slabel
timestamp
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.timestamp
smany
true
seditCols
2
sinitialization
false
sdescription
可选的<tt class="literal"><font face="新宋体"><timestamp></timestamp></font></tt>元素指明了表中包含时间戳数据。 这用来作为版本的替代。时间戳本质上是一种对乐观锁定的一种不是特别安全的实现。当然， 有时候应用程序可能在其他方面使用时间戳。<br /><br />注意，<tt class="literal"><font face="新宋体">&lt;timestamp&gt;</font></tt> 和<tt class="literal"><font face="新宋体">&lt;version type=&quot;timestamp&quot;&gt;</font></tt>是等价的。
sid
timestamp
@xworker.db.hibernate.hibernate-mapping-nodes.class/@property
sname
property
slabel
property
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.property
smany
true
seditCols
2
sinitialization
false
sid
property
@xworker.db.hibernate.hibernate-mapping-nodes.class/@many-to-one
sname
many-to-one
slabel
many-to-one
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.many-to-one
smany
true
seditCols
2
sinitialization
false
sdescription
通过<tt class="literal"><font face="新宋体">many-to-one</font></tt>元素,可以定义一种常见的与另一个持久化类的关联。 这种关系模型是多对一关联（实际上是一个对象引用－译注）：这个表的一个外键引用目标表的 主键字段。
sid
many-to-one
@xworker.db.hibernate.hibernate-mapping-nodes.class/@one-to-one
sname
one-to-one
slabel
one-to-one
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.one-to-one
smany
true
seditCols
2
sinitialization
false
Sdescription
#$@text#$@
持久化对象之间一对一的关联关系是通过<tt class="literal"><font face="新宋体">one-to-one</font></tt>元素定义的。<br /><br />
<p>有两种不同的一对一关联： </p>
<div class="itemizedlist">
<ul type="disc">
    <li>
    <p>主键关联 </p>
    </li>
    <li>
    <p>惟一外键关联 </p>
    </li>
</ul>
</div>
<p>主键关联不需要额外的表字段；如果两行是通过这种一对一关系相关联的，那么这两行就共享同样的主关键字值。所以如果你希望两个对象通过主键一对一关联，你必须确认它们被赋予同样的标识值！</p>
#$@text#$@
sid
one-to-one
@xworker.db.hibernate.hibernate-mapping-nodes.class/@component
sname
component
slabel
component
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.component
smany
true
seditCols
2
sinitialization
false
sdescription
<font face="新宋体">&lt;component&gt;</font>元素把子对象的一些元素与父类对应的表的一些字段映射起来。 然后组件可以定义它们自己的属性、组件或者集合。参见后面的&ldquo;Components&rdquo;一章。
sid
component
@xworker.db.hibernate.hibernate-mapping-nodes.class/@dynamic-component
sname
dynamic-component
slabel
dynamic-component
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.dynamic-component
smany
true
seditCols
2
sinitialization
false
sid
dynamic-component
@xworker.db.hibernate.hibernate-mapping-nodes.class/@properties
sname
properties
slabel
properties
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.properties
smany
true
seditCols
2
sinitialization
false
sdescription
<font face="新宋体">&lt;properties&gt;</font> 元素允许定义一个命名的逻辑分组(grouping)包含一个类中的多个属性。 这个元素最重要的用处是允许多个属性的组合作为<tt class="literal"><font face="新宋体">property-ref</font></tt>的目标(target)。 这也是定义多字段唯一约束的一种方便途径。
sid
properties
@xworker.db.hibernate.hibernate-mapping-nodes.class/@any
sname
any
slabel
any
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.any
smany
true
seditCols
2
sinitialization
false
sid
any
@xworker.db.hibernate.hibernate-mapping-nodes.class/@map
sname
map
slabel
map
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.map
smany
true
seditCols
2
sinitialization
false
sid
map
@xworker.db.hibernate.hibernate-mapping-nodes.class/@set
sname
set
slabel
set
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.set
smany
true
seditCols
2
sinitialization
false
sid
set
@xworker.db.hibernate.hibernate-mapping-nodes.class/@list
sname
list
slabel
list
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.list
smany
true
seditCols
2
sinitialization
false
sid
list
@xworker.db.hibernate.hibernate-mapping-nodes.class/@bag
sname
bag
slabel
bag
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.bag
smany
true
seditCols
2
sinitialization
false
sid
bag
@xworker.db.hibernate.hibernate-mapping-nodes.class/@idbag
sname
idbag
slabel
idbag
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.idbag
smany
true
seditCols
2
sinitialization
false
sid
idbag
@xworker.db.hibernate.hibernate-mapping-nodes.class/@array
sname
array
slabel
array
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.array
smany
true
seditCols
2
sinitialization
false
sid
array
@xworker.db.hibernate.hibernate-mapping-nodes.class/@primitive-array
sname
primitive-array
slabel
primitive-array
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.primitive-array
smany
true
seditCols
2
sinitialization
false
sid
primitive-array
@xworker.db.hibernate.hibernate-mapping-nodes.class/@join
sname
join
slabel
join
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
dbhibernate:hibernate-mapping-nodes.join:
smany
true
seditCols
2
sinitialization
false
sdescription
使用<font face="新宋体">&lt;join&gt;</font> <tt class="literal"><font face="新宋体"><join></join></font></tt>元素，可以将一个类的属性映射到多张表中。<br /><br />此特性常常对遗留数据模型有用，我们推荐表个数比类个数少，以及细粒度的领域模型。然而，在单独的继承树上切换继承映射策略是有用的，后面会解释这点。
sid
join
@xworker.db.hibernate.hibernate-mapping-nodes.class/@subclass
sname
subclass
slabel
subclass
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.subclass
smany
true
seditCols
2
sinitialization
false
sdescription
最后，多态持久化需要为父类的每个子类都进行定义。对于&ldquo;每一棵类继承树对应一个表&rdquo;的策略来说，就需要使用<tt class="literal"><font face="新宋体">&lt;subclass&gt;</font></tt>定义。<br /><br />每个子类都应该定义它自己的持久化属性和子类。 <tt class="literal"><font face="新宋体">&lt;version&gt;</font></tt> 和<tt class="literal"><font face="新宋体">&lt;id&gt;</font></tt> 属性可以从根父类继承下来。在一棵继承树上的每个子类都必须定义一个唯一的<tt class="literal"><font face="新宋体">discriminator-value</font></tt>。如果没有指定，就会使用Java类的全限定名。<br /><br />可以在单独的映射文件中，直接在<tt class="literal"><font face="新宋体">hibernate-mapping</font></tt>下定义<tt class="literal"><font face="新宋体">subclass</font></tt>，<tt class="literal"><font face="新宋体">union-subclass</font></tt>和<tt class="literal"><font face="新宋体">joined-subclass</font></tt>映射。这样你只要增加一个新的映射文件就可以继承一棵类继承树。你必须在子类的映射中指定<tt class="literal"><font face="新宋体">extends</font></tt> 属性来指定已映射的超类。注意：以前，这个特性使得映射文件的顺序变得很重要。从Hibernate3开始，当使用extends关键字的时候，映射文件的次序便不重要了。而在单一映射文件中，依旧需要保持将超类定义在子类之前这样的次序
sid
subclass
@xworker.db.hibernate.hibernate-mapping-nodes.class/@joined-subclass
sname
joined-subclass
slabel
joined-subclass
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.joined-subclass
smany
true
seditCols
2
sinitialization
false
sid
joined-subclass
@xworker.db.hibernate.hibernate-mapping-nodes.class/@union-subclass
sname
union-subclass
slabel
union-subclass
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.union-subclass
smany
true
seditCols
2
sinitialization
false
sid
union-subclass
@xworker.db.hibernate.hibernate-mapping-nodes.class/@loader
sname
loader
slabel
loader
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.loader
smany
true
seditCols
2
sinitialization
false
sid
loader
@xworker.db.hibernate.hibernate-mapping-nodes.class/@sql-insert
sname
sql-insert
slabel
sql-insert
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.sql-insert
smany
true
seditCols
2
sinitialization
false
sid
sql-insert
@xworker.db.hibernate.hibernate-mapping-nodes.class/@sql-update
sname
sql-update
slabel
sql-update
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.sql-update
smany
true
seditCols
2
sinitialization
false
sid
sql-update
@xworker.db.hibernate.hibernate-mapping-nodes.class/@sql-delete
sname
sql-delete
slabel
sql-delete
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.sql-delete
smany
true
seditCols
2
sinitialization
false
sid
sql-delete
@xworker.db.hibernate.hibernate-mapping-nodes.class/@filter
sname
filter
slabel
filter
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.filter
smany
true
seditCols
2
sinitialization
false
sid
filter
@xworker.db.hibernate.hibernate-mapping-nodes.class/@resultset
sname
resultset
slabel
resultset
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.resultset
smany
true
seditCols
2
sinitialization
false
sid
resultset
@xworker.db.hibernate.hibernate-mapping-nodes.class/@query
sname
query
slabel
query
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.query
smany
true
seditCols
2
sinitialization
false
sid
query
@xworker.db.hibernate.hibernate-mapping-nodes.class/@sql-query
sname
sql-query
slabel
sql-query
sdescriptors
xworker.lang.MetaDescriptor3/@thing
sextends
xworker.db.hibernate.hibernate-mapping-nodes.sql-query
smany
true
seditCols
2
sinitialization
false
sid
sql-query
