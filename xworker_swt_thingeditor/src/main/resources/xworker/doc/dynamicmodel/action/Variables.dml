^1627626942255
@
sname
Variables
slabel
动作上下文
stype
thingDesc
sgroup
dynamicModel.-990|Actions.variables
sgroupDescriptor
true
sicon
icons/html.png
sth_sortWeight
-11000
sstyledTextForInsert
parentContext.parentContext.codeText
suseTargetThingDoc
false
ssimpleBrowser
true
shideOutline
false
Sdescription
#$@text#$@
<h1>动作上下文</h1>

<h2>1.简介</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;动作上下文是动作执行的环境，执行一个动作必须要有动作上下文。</p>

<p>&nbsp;&nbsp;&nbsp; 动作的执行环境主要包含两个，一个是变量，一个是线程状态。由于动态上下文大多时候用于管理变量，所以动作上下文有时也叫做变量上下文。</p>

<h2>2.管理变量</h2>

<h3>2.1.基本概念</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 动作上下文是一个栈，栈的每一层相当于一个Map&lt;String, Object&gt;，动作上下文整体也可以看作是一个Map&lt;String, Object&gt;。可以通过变量上下文设置和获取变量，也可以通过栈直接设置和获取某一个栈层的变量。</p>

<p>&nbsp;&nbsp;&nbsp; 需要主意的是，<strong>线程不共用栈</strong>。即同一个变量上下文，在不同的线程里，线程使用各自的栈，在线程中push()或pop()不影响其它线程。</p>

<p>&nbsp;&nbsp;&nbsp; 尽管不同的线程使用不同的栈，但是<strong>最底层的栈层是线程共用</strong>的。</p>

<h3>2.2.变量的获取顺序</h3>

<p>&nbsp;&nbsp;&nbsp; 通过变量上下文获取变量时，是从栈的上层向下层依次获取的，如果某一个栈层有这个变量则返回，其中上层的栈是最新压入的栈层。</p>

<p>&nbsp;&nbsp;&nbsp; 获取变量的示意代码如下。</p>

<pre class="brush:as3;">
                Object value = null;
		Stack&lt;Bindings&gt; bindingsStack = getBindingStack();
		for (int i = bindingsStack.size() - 1; i &gt;= 0; i--) {
		       Map&lt;String, Object&gt; map = bindingsStack.get(i);
			value = map.get(key);

			if (value != null) {
				break;
			} else if (map.containsKey(key)) {
				break;
			}
		}

		return value;</pre>

<h3>2.3.变量范围</h3>

<p>&nbsp;&nbsp;&nbsp; 可以根据动态上下文的栈来实现相对的全局变量和局部变量的概念。</p>

<p>&nbsp;&nbsp;&nbsp; <strong>局部变量，</strong>可以理解成临时加入的变量，当使用时就压入一个栈层，在这个栈层中设置变量，当使用完毕后就弹出该栈层，这样变量就消失了。需要注意的是，使用局部变量时push和pop必须是成对出现的，并放到try/finally里。</p>

<p>&nbsp;&nbsp;&nbsp; <strong>全局变量</strong>，由于动作上下文最底层的栈层是所有线程共享的，并且日常使用中也不会被弹出，所以这个栈层的变量可以当成全局变量。</p>

<h2>3.线程状态</h2>

<p>&nbsp;&nbsp;&nbsp; 线程状态用来指示动作的行为的，线程状态和语法类的动作相关。线程状态主要有RUNNING、RETURN、BREAK、BREAK、CONTINUE和EXCEPTION几种。</p>

<p>&nbsp;&nbsp;&nbsp; 比如有一个动作是while循环，示意代码如下。</p>

<pre class="brush:groovy;">
import org.xmeta.Thing;
import org.xmtea.ActionContext;

//while动作模型自己
Thing self = ...;

Object result = null;
List&lt;Thing&gt; childs = self.getChilds();
while(self.doAction(&quot;condition&quot;, actionContext){
    for(Thing child : childs){
        result = child.getAction().run(actionContext);

        int status = actionContext.getStatus();
        if(status == ActionContext.RETURN){
            //子节点执行的return方法
            return result;
        }else if(status == ActionContext.BREAK){
           //子节点要求break
            break;
        }else if(status == ActionContext.CONTINUE){
           //子节点要求continue;
           continue;
        }
    }
}

return result;
</pre>
#$@text#$@
sen_label
ActionContext
sdescriptors
xworker.content.QuickContent
sinheritDescription
false
sth_createIndex
true
sth_registThing
child|xworker.example.ExamplesIndex
sth_registMyChilds
false
sth_registDisabled
false
sth_noThingRegistViewer
false
sth_fileMonitor
false
Sen_description
#$@text#$@
<h1>Action context</h1>

<h2>1. Introduction</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;The action context is the environment in which the action is executed, and an action context is required to execute an action. </p>

<p>&nbsp;&nbsp;&nbsp; The execution environment of the action mainly contains two, one is the variable, the other is the thread state. Since dynamic context is mostly used to manage variables, action context is sometimes called variable context. </p>

<h2>2. Manage variables</h2>

<h3>2.1. Basic concepts</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp; The action context is a stack, each layer of the stack is equivalent to a Map&lt;String, Object&gt;, and the whole action context can also be regarded as a Map&lt;String, Object&gt;. Variables can be set and obtained through the variable context, or variables of a certain stack layer can be set and obtained directly through the stack. </p>

<p>&nbsp;&nbsp;&nbsp; It is important to note that <strong>threads do not share stacks</strong>. That is, in the same variable context, in different threads, the threads use their own stacks, and push() or pop() in the thread does not affect other threads. </p>

<p>&nbsp;&nbsp;&nbsp; Although different threads use different stacks, <strong>the lowest stack layer is shared by threads</strong>. </p>

<h3>2.2. Acquisition order of variables</h3>

<p>&nbsp;&nbsp;&nbsp; When obtaining variables through the variable context, they are obtained sequentially from the upper layer of the stack to the lower layer. If there is this variable in a certain stack layer, it will return. The upper stack is the newly pushed stack layer. </p>

<p>&nbsp;&nbsp;&nbsp; The schematic code for obtaining variables is as follows. </p>

<pre class="brush:as3;">
                Object value = null;
Stack&lt;Bindings&gt; bindingsStack = getBindingStack();
for (int i = bindingsStack.size()-1; i &gt;= 0; i--) {
Map&lt;String, Object&gt; map = bindingsStack.get(i);
value = map.get(key);

if (value != null) {
break;
} else if (map.containsKey(key)) {
break;
}
}

return value;</pre>

<h3>2.3. Variable scope</h3>

<p>&nbsp;&nbsp;&nbsp; The concept of relative global variables and local variables can be realized based on the dynamic context stack. </p>

<p>&nbsp;&nbsp;&nbsp; <strong>Local variables,</strong> can be understood as temporarily added variables. When used, they are pushed into a stack layer, and variables are set in this stack layer. Pop the stack layer so that the variable disappears. It should be noted that when using local variables, push and pop must be paired and placed in try/finally. </p>

<p>&nbsp;&nbsp;&nbsp; <strong>Global Variables</strong>, since the bottom stack layer of the action context is shared by all threads and will not be popped out in daily use, the variables of this stack layer can be As a global variable. </p>

<h2>3. Thread status</h2>

<p>&nbsp;&nbsp;&nbsp; The thread state is used to indicate the behavior of the action, and the thread state is related to the action of the syntax type. The thread states mainly include RUNNING, RETURN, BREAK, BREAK, CONTINUE and EXCEPTION. </p>

<p>&nbsp;&nbsp;&nbsp; For example, an action is a while loop, and the code is as follows. </p>

<pre class="brush:groovy;">
import org.xmeta.Thing;
import org.xmtea.ActionContext;

//while action model itself
Thing self = ...;

Object result = null;
List&lt;Thing&gt; childs = self.getChilds();
while(self.doAction(&quot;condition&quot;, actionContext){
    for(Thing child: childs){
        result = child.getAction().run(actionContext);

        int status = actionContext.getStatus();
        if(status == ActionContext.RETURN){
            //The return method executed by the child node
            return result;
        }else if(status == ActionContext.BREAK){
           //The child node requires break
            break;
        }else if(status == ActionContext.CONTINUE){
           //The child node requires continue;
           continue;
        }
    }
}

return result;
</pre>
#$@text#$@
sth_mark
false
sth_registQueryOnlySelf
false
