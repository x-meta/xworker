^1627639373272
@
sname
UseVariables
slabel
使用变量
stype
thingDesc
sgroup
dynamicModel.-990|Actions.variables
sgroupDescriptor
false
sicon
icons/html.png
sth_sortWeight
30
sstyledTextForInsert
parentContext.parentContext.codeText
suseTargetThingDoc
false
ssimpleBrowser
true
shideOutline
false
Sdescription
#$@text#$@
<h1>使用变量</h1>

<p>&nbsp;&nbsp;&nbsp; 动作上下文中和使用变量相关的一些知识和技巧。</p>

<h2>1.特殊变量</h2>

<p>&nbsp;&nbsp;&nbsp; 这些特殊变量应该保持其约定的用法，不要随意更改其用法。</p>

<h3>1.1.actionContext</h3>

<p>&nbsp;&nbsp;&nbsp; 通常动作上下文会把自己也作为一个变量放到自己里面，其中变量名是actionContext，见下面的ActionContext构造函数示意代码。</p>

<pre class="brush:java;">
public class ActionContext{
    public ActionContext(){
        this.put(&quot;actionContext&quot;, this);
    }
}</pre>

<p>&nbsp;&nbsp;&nbsp; 因此在动作上下文里获取actionContext变量是它自己。设置actionContext变量的目的是在一些脚本模型里能够正确得到动作上下文，因为用户有可能需要使用动作上下文这个对象本身。</p>

<h3>1.2.parentContext</h3>

<p>&nbsp;&nbsp;&nbsp; parentContext是父动作上下文，parentContext变量有可能不存在。</p>

<p>&nbsp;&nbsp;&nbsp; 它的场合一般用在变量隔离上。比如在动作里调用其它动作，为了避免可能的变量混淆，可以创建新的变量上下文，在新的变量上下文里把当前变量上下文设置为parentContext变量。</p>

<p>&nbsp;&nbsp;&nbsp; 设置parentContext需要用户自行操作，如下面的代码。</p>

<pre class="brush:java;">
public static Object doSomeThing(ActionContext actionContext){
     ActionContext context = new ActionContext();
     context.put(&quot;parentContext&quot;, actionContext);

     ......
}</pre>

<h3>1.3.world</h3>

<p>&nbsp;&nbsp;&nbsp; 引擎的实例(org.xmeta.World)，动作上下文总是含有此变量。</p>

<h2>2.在脚本模型中使用变量</h2>

<p>&nbsp;&nbsp;&nbsp; 在一些脚本模型里（参看脚本模型的文档说明），如GroovyAction模型里，可以直接使用变量，而无需通过动作上下文获取变量。</p>

<p>&nbsp;&nbsp;&nbsp; 比如如果动作上下文中有一个名为name的变量，那么在Groovy脚本里就可以像下面这样直接使用。</p>

<pre class="brush:groovy;">
//直接使用name变量
println name;</pre>

<h2>3.明确的设置变量</h2>

<p>&nbsp;&nbsp;&nbsp; 避免通过ActionContext.put()方法直接设置变量，而应该首先获取想要的栈层，然后通过该栈层设置变量。</p>

<p>&nbsp;&nbsp;&nbsp; 获取栈层的方法主要有如下：</p>

<pre class="brush:groovy;">
import org.xmeta.Bindings;

//获取全局变量栈
Bindings bindings = actionContext.g();

//获取本地变量栈，可能为null
Bindings bindings = actionConext.l();

//获取顶层栈层
Bindings bindings = actionContext.peek();

//获取压入的栈层
Binding bindings = actionContext.push(null);
try{
}finally{
    actionContext.pop();
}</pre>

<h2>4.变量隔离</h2>

<p>&nbsp;&nbsp;&nbsp; 为什么需要变量隔离呢？是因为一般情况下我们并不知道动作上下文里有哪些变量。</p>

<p>&nbsp;&nbsp;&nbsp; 因为动作相当于函数和方法，动作可以在动作里调用其它动作，而每一个动作都可以修改动作上下文，设置其中的变量。这样经过n个动作后，加上动态模型没有严格明确的变量申明的方法，因此很难知道动作上下文中有哪些变量。</p>

<p>&nbsp;&nbsp;&nbsp; 不知道动作上下文中有哪些变量，这看似是一个严重的问题，但在实际编程中并不会引起太大的问题，但是为了确保在某些场合下变量管理不会出现问题，此时需要注意变量的隔离。</p>

<p>&nbsp;&nbsp;&nbsp; 变量隔离的基本做法就是申明新的动作上下文去执行目标动作。比如在界面模型里，每一个模型节点执行后会创建界面控件对象到动作上下文中，当在一个界面打开另一个界面时，为了避免新的界面的变量覆盖当前界面的变量，会使用新的动作上下文去打开新的界面。</p>

<p>&nbsp;&nbsp;&nbsp; 总之，变量隔离是需要关注的事情。</p>

<p>&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;</p>
#$@text#$@
sen_label
Use Variables
sdescriptors
xworker.content.QuickContent
sinheritDescription
false
sth_createIndex
true
sth_registThing
child|xworker.example.ExamplesIndex
sth_registMyChilds
false
sth_registDisabled
false
sth_noThingRegistViewer
false
sth_fileMonitor
false
Sen_description
#$@text#$@
<h1>Use variables</h1>

<p>&nbsp;&nbsp;&nbsp; Some knowledge and skills related to the use of variables in the context of actions. </p>

<h2>1. Special variables</h2>

<p>&nbsp;&nbsp;&nbsp; These special variables should maintain their agreed usage, and do not change their usage at will. </p>

<h3>1.1.actionContext</h3>

<p>&nbsp;&nbsp;&nbsp; Usually the action context puts itself as a variable in itself, where the variable name is actionContext, see the following ActionContext constructor for the code. </p>

<pre class="brush:java;">
public class ActionContext{
    public ActionContext(){
        this.put(&quot;actionContext&quot;, this);
    }
}</pre>

<p>&nbsp;&nbsp;&nbsp; So it is its own to get the actionContext variable in the action context. The purpose of setting the actionContext variable is to get the action context correctly in some script models, because the user may need to use the action context object itself. </p>

<h3>1.2.parentContext</h3>

<p>&nbsp;&nbsp;&nbsp; parentContext is the parent action context, and the parentContext variable may not exist. </p>

<p>&nbsp;&nbsp;&nbsp; Its occasion is generally used for variable isolation. For example, to call other actions in an action, in order to avoid possible variable confusion, you can create a new variable context, and set the current variable context as the parentContext variable in the new variable context. </p>

<p>&nbsp;&nbsp;&nbsp; Setting the parentContext requires the user to operate by himself, as shown in the following code. </p>

<pre class="brush:java;">
public static Object doSomeThing(ActionContext actionContext){
     ActionContext context = new ActionContext();
     context.put(&quot;parentContext&quot;, actionContext);

     ......
}</pre>

<h3>1.3.world</h3>

<p>&nbsp;&nbsp;&nbsp; The instance of the engine (org.xmeta.World), the action context always contains this variable. </p>

<h2>2. Use variables in the script model</h2>

<p>&nbsp;&nbsp;&nbsp; In some scripting models (refer to the documentation of the scripting model), such as the GroovyAction model, variables can be used directly without getting the variables through the action context. </p>

<p>&nbsp;&nbsp;&nbsp; For example, if there is a variable named name in the action context, it can be used directly in the Groovy script as follows. </p>

<pre class="brush:groovy;">
//Use the name variable directly
println name;</pre>

<h2>3. Clearly set variables</h2>

<p>&nbsp;&nbsp;&nbsp; Avoid setting variables directly through the ActionContext.put() method, but first obtain the desired stack layer, and then set the variable through the stack layer. </p>

<p>&nbsp;&nbsp;&nbsp; The main methods of obtaining the stack layer are as follows:</p>

<pre class="brush:groovy;">
import org.xmeta.Bindings;

//Get global variable stack
Bindings bindings = actionContext.g();

//Get the local variable stack, which may be null
Bindings bindings = actionConext.l();

//Get the top stack layer
Bindings bindings = actionContext.peek();

//Get the pressed stack layer
Binding bindings = actionContext.push(null);
try{
}finally{
    actionContext.pop();
}</pre>

<h2>4. Variable isolation</h2>

<p>&nbsp;&nbsp;&nbsp; Why do we need variable isolation? It's because we generally don't know what variables are in the action context. </p>

<p>&nbsp;&nbsp;&nbsp; Because actions are equivalent to functions and methods, actions can call other actions in actions, and each action can modify the action context and set its variables. In this way, after n actions, the dynamic model does not have a strict and clear variable declaration method, so it is difficult to know which variables are in the action context. </p>

<p>&nbsp;&nbsp;&nbsp; I don’t know what variables are in the action context. This seems to be a serious problem, but it won’t cause too much problem in actual programming, but to ensure that variables are used in certain situations There will be no problems with management. At this time, attention needs to be paid to the isolation of variables. </p>

<p>&nbsp;&nbsp;&nbsp; The basic method of variable isolation is to declare a new action context to execute the target action. For example, in the interface model, after each model node is executed, an interface control object will be created in the action context. When one interface is opened on another interface, in order to prevent the new interface variables from overwriting the current interface variables, new actions will be used Context to open a new interface. </p>

<p>&nbsp;&nbsp;&nbsp; In short, variable isolation is something that needs attention. </p>

<p>&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;</p>
#$@text#$@
sth_mark
false
sth_registQueryOnlySelf
false
