^1627639373272
@
sname
UseVariables
slabel
使用变量
stype
thingDesc
sgroup
dynamicModel.-990|Actions.variables
sgroupDescriptor
false
sicon
icons/html.png
sth_sortWeight
30
sstyledTextForInsert
parentContext.parentContext.codeText
suseTargetThingDoc
false
ssimpleBrowser
true
shideOutline
false
Sdescription
#$@text#$@
<h1>使用变量</h1>

<p>&nbsp;&nbsp;&nbsp; 动作上下文中和使用变量相关的一些知识和技巧。</p>

<h2>1.特殊变量</h2>

<p>&nbsp;&nbsp;&nbsp; 这些特殊变量应该保持其约定的用法，不要随意更改其用法。</p>

<h3>1.1.actionContext</h3>

<p>&nbsp;&nbsp;&nbsp; 通常动作上下文会把自己也作为一个变量放到自己里面，其中变量名是actionContext，见下面的ActionContext构造函数示意代码。</p>

<pre class="brush:java;">
public class ActionContext{
    public ActionContext(){
        this.put(&quot;actionContext&quot;, this);
    }
}</pre>

<p>&nbsp;&nbsp;&nbsp; 因此在动作上下文里获取actionContext变量是它自己。设置actionContext变量的目的是在一些脚本模型里能够正确得到动作上下文，因为用户有可能需要使用动作上下文这个对象本身。</p>

<h3>1.2.parentContext</h3>

<p>&nbsp;&nbsp;&nbsp; parentContext是父动作上下文，parentContext变量有可能不存在。</p>

<p>&nbsp;&nbsp;&nbsp; 它的场合一般用在变量隔离上。比如在动作里调用其它动作，为了避免可能的变量混淆，可以创建新的变量上下文，在新的变量上下文里把当前变量上下文设置为parentContext变量。</p>

<p>&nbsp;&nbsp;&nbsp; 设置parentContext需要用户自行操作，如下面的代码。</p>

<pre class="brush:java;">
public static Object doSomeThing(ActionContext actionContext){
     ActionContext context = new ActionContext();
     context.put(&quot;parentContext&quot;, actionContext);

     ......
}</pre>

<h3>1.3.world</h3>

<p>&nbsp;&nbsp;&nbsp; 引擎的实例(org.xmeta.World)，动作上下文总是含有此变量。</p>

<h2>2.在脚本模型中使用变量</h2>

<p>&nbsp;&nbsp;&nbsp; 在一些脚本模型里（参看脚本模型的文档说明），如GroovyAction模型里，可以直接使用变量，而无需通过动作上下文获取变量。</p>

<p>&nbsp;&nbsp;&nbsp; 比如如果动作上下文中有一个名为name的变量，那么在Groovy脚本里就可以像下面这样直接使用。</p>

<pre class="brush:groovy;">
//直接使用name变量
println name;</pre>

<h2>3.明确的设置变量</h2>

<p>&nbsp;&nbsp;&nbsp; 避免通过ActionContext.put()方法直接设置变量，而应该首先获取想要的栈层，然后通过该栈层设置变量。</p>

<p>&nbsp;&nbsp;&nbsp; 获取栈层的方法主要有如下：</p>

<pre class="brush:groovy;">
import org.xmeta.Bindings;

//获取全局变量栈
Bindings bindings = actionContext.g();

//获取本地变量栈，可能为null
Bindings bindings = actionConext.l();

//获取顶层栈层
Bindings bindings = actionContext.peek();

//获取压入的栈层
Binding bindings = actionContext.push(null);
try{
}finally{
    actionContext.pop();
}</pre>

<h2>4.变量隔离</h2>

<p>&nbsp;&nbsp;&nbsp; 为什么需要变量隔离呢？是因为一般情况下我们并不知道动作上下文里有哪些变量。</p>

<p>&nbsp;&nbsp;&nbsp; 因为动作相当于函数和方法，动作可以在动作里调用其它动作，而每一个动作都可以修改动作上下文，设置其中的变量。这样经过n个动作后，加上动态模型没有严格明确的变量申明的方法，因此很难知道动作上下文中有哪些变量。</p>

<p>&nbsp;&nbsp;&nbsp; 不知道动作上下文中有哪些变量，这看似是一个严重的问题，但在实际编程中并不会引起太大的问题，但是为了确保在某些场合下变量管理不会出现问题，此时需要注意变量的隔离。</p>

<p>&nbsp;&nbsp;&nbsp; 变量隔离的基本做法就是申明新的动作上下文去执行目标动作。比如在界面模型里，每一个模型节点执行后会创建界面控件对象到动作上下文中，当在一个界面打开另一个界面时，为了避免新的界面的变量覆盖当前界面的变量，会使用新的动作上下文去打开新的界面。</p>

<p>&nbsp;&nbsp;&nbsp; 总之，变量隔离是需要关注的事情。</p>

<p>&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;</p>
#$@text#$@
sen_label
Use Variables
sdescriptors
xworker.content.QuickContent
sinheritDescription
false
sth_createIndex
true
sth_registThing
child|xworker.example.ExamplesIndex
sth_registMyChilds
false
sth_registDisabled
false
sth_noThingRegistViewer
false
sth_fileMonitor
false
sth_mark
false
sth_registQueryOnlySelf
false
