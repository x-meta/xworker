<?xml version='1.0' encoding='utf-8'?>

<QuickContent name="ActionDesc" descriptors="xworker.content.QuickContent" label="动作" type="thingDesc"
     group="dynamicModel.-990|Actions" groupDescriptor="true" icon="icons/html.png" th_sortWeight="-990"
     simpleBrowser="true" en_label="Action" th_createIndex="true" th_registThing="child|xworker.example.ExamplesIndex">&#xd;
    <description><![CDATA[<h1>动作</h1>

<h2>1.简介</h2>

<p>&nbsp;&nbsp;&nbsp; 模型是像XML这样的数据，数据本身不能直接运行，而动作就是让模型变成可执行的方法，从而让动态模型真正成为一种编程方法。</p>

<h2>2.让模型可执行的原理</h2>

<p>&nbsp;&nbsp;&nbsp; 模型的执行原理在<a href="javascript:invoke('action:xworker.swt.xworker.prototype.ThingRegistSelector/@actions/@utilBrowserSelectThing?thing=xworker.doc.dyanmicmodel.DynamicModel')">动态模型</a>的文档里已经介绍过了，这里再详细解释一下。</p>

<h3>2.1.模型是解释执行的</h3>

<p>&nbsp;&nbsp;&nbsp; 模型本身是数据，说执行一个模型，实际上在执行一个解释程序，这个程序可以处理模型数据。比如要执行代码：&quot;return x + y；&quot;，代码本身是数据，可以用模型来表示，要让它执行，就是要编写一个程序来解释执行&quot;return x + y;&quot;这段代码。当解释程序执行后就相当于&quot;return x&nbsp;+ y;&quot;这段代码执行了。</p>

<h3>2.2.循环解释执行</h3>

<p>&nbsp;&nbsp;&nbsp; 如果认识到代码可以是数据，解释执行代码数据可以等同为代码的执行，那么就可以设计一个任意模型的执行方法了。</p>

<ol>
	<li>首先假设任意模型都是可执行的，要运行是一个模型，可以把它转化为动作，动作实际上是模型的名字为run的方法(模型也是对象，有自己的行为）。</li>
	<li>而模型名字为run的方法也是一个模型，要运行run方法这个模型，同样运行它的run方法。</li>
	<li>以上是一个迭代的过程，要想让迭代能够终止，那么存在一些模型是不需要执行它的run方法，而是由引擎直接解释执行。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp; 以上就是让模型可执行的原理，实际上就是要让任何模型的执行迭代到元系统（实现动态模型的系统）执行上。如XWorker的动态模型是使用Java编写的，意思就是它是一个Java程序，最终的执行都是Java代码的执行。</p>

<h3>2.3.解决动作模型的局限性</h3>

<p>&nbsp;&nbsp;&nbsp; 由于模型都是最终由元系统（实现动态模型的系统）解释执行的，那么就存在一个问题，即现有的元系统上的解释程序是否可以解释执行任意的模型？要解决这个问题，一般可以采用下面方法。</p>

<h4>2.3.1.编写语法类的动作模型</h4>

<p>&nbsp;&nbsp;&nbsp; 可以编写各种语法类的动作模型。Java的各种语法都可以封装为相应的动作模型，如try/catch、while等等动作模型。</p>

<p>&nbsp;&nbsp;&nbsp; 可以编写语法类的动作模型，是在说用模型可以构建新的编程语言，当有了使用模型编写的编程语言时，理论上就可以用模型解释执行任意模型了。不过实际编程中还是建议使用Java编写动作模型，这样便于调试执行性能也高。</p>

<h4>2.3.2.使用脚本类的动作模型</h4>

<p>&nbsp;&nbsp;&nbsp; 可以使用脚本类的动作模型，通过脚本类模型可以运行脚本，而脚本是可以随时编写和运行的。如Groovy、Js、BeanShell、Lua等等脚本模型。</p>

<h3>2.4.行为的获取顺序</h3>

<p>&nbsp;&nbsp;&nbsp; 由于模型对象的行为可以在模型对象自身定义，也可以继承于它的类和其它对象，那么如果自身和类等都定义的同名的动作，那么对象该使用具体的哪一个呢？</p>

<p>&nbsp;&nbsp;&nbsp; 对象行为的获取顺序如下，如果获取到了则后面的不再获取。</p>

<ol>
	<li>从自身定义的行为中获取。</li>
	<li>从它的描述者（类）自身定义的行为中获取。</li>
	<li>从它继承的其它对象自身定义的行为中获取。</li>
	<li>从它的描述者（类）继承的行为上获取。</li>
	<li>从它继承的其它对象继承的行为上获取。</li>
</ol>

<h2>3.动作的实现</h2>

<p>&nbsp;&nbsp;&nbsp; 用示意代码来解释动作是如何实现的。</p>

<h3>3.1.转化为动作</h3>

<pre class="brush:java;">
import org.xmeta.Action;
import org.xmeta.Thing;

//Thing是模型
Thing thing = ......;

//Action是动作，模型可以转化为动作
Action action = thing.getAction();</pre>

<p>&nbsp;&nbsp;&nbsp; getAction()的示意代码。</p>

<pre class="brush:java;">
package org.xmeta;

public class Thing{
     public Action getAction(){
         return new Action(this);
     }
}</pre>

<h3>3.2.执行动作</h3>

<pre class="brush:java;">
import org.xmeta.ActionContext;

Object result = action.run(new ActionContext());</pre>

<p>&nbsp;&nbsp;&nbsp; 可以调用动作的run()方法来执行，其中需要参数ActionContext，ActionContext是动作执行的上下文，用来管理变量栈和线程状态等。&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp; run()方法的实现代码代码大意如下。</p>

<pre class="brush:java;">
package org.xmeta;

public class Action{
    public Object run(ActionContext actionContext){
        //转化为动作时的模型
        Thing thing = getThing();
        
        //thingName是模型的类型名
        if(&quot;JavaAction&quot;.equlas(thing.getThingName()){
             //执行模型指定的Java方法。这里是迭代的终止
             return javaMethod.invoke(actionContext);
        }else{
             //获取模型的run方法
             Thing runThing = thing.getActionThing(&quot;run&quot;);
             //把run方法转化为动作执行。这里形成迭代
             return runThing.getAction().run(actionContext);
        }
    }
}</pre>

<h2>4.动作的用途</h2>

<h3>4.1.可以作为函数和方法来使用</h3>

<pre class="brush:java;">
import org.xmeta.Action;
import org.xmeta.ActionContext;
import org.xmeta.Thing;

//从模型获取动作
Thing thing = ...;
Action action = thing.getAction();

//执行动作
ActionContext actionContext = new ActionContext();
Object result = actionContext.run(actionContext);

//传参执行，参数是通过名字传入的
Object result = actionContext.run(actionContext, &quot;x&quot;, 1, &quot;y&quot;, 2);
</pre>

<h3>4.2.可以作为对象的行为来执行</h3>

<pre class="brush:java;">
import org.xmeta.ActionContext;
import org.xmeta.Thing;

//获取模型
Thing thing = ...;

ActionContext actionContext = new ActionContext();

//执行它的行为
Object result = thing.doAction(&quot;run&quot;, actionContext);

//执行它的行为，传入参数
Object result = thing.doAction(&quot;run&quot;, actionContext, &quot;x&quot;, 1, &quot;y&quot;, 2);</pre>

<p>&nbsp;&nbsp;&nbsp; 执行对象行为的原理，示意代码如下。</p>

<pre class="brush:java;">
import org.xmeta.ActionContext;
import org.xmeta.Thing;

public class Thing{
     public Object doActin(String name, ActionContext actionContext, Object ... params){
         //获取动作模型的定义
         Thing actionThing = getActionThing(name);
         //转化为动作
         Action action = actionThing.getAction();

         //把参数转化为Map
         Map&lt;String, Object&gt; paramsMap = UtilMap.toMap(params);
         
         //创建要给变量栈
         Bindings bindings = actionContext.push();
         try{
              //放入参数
              bindings.putAll(paramsMap);
              //放入自己
              bindings.put(&quot;self&quot;, this);

              //执行
              return action.run(actionContext);
         }finally{
             //弹出变量栈，和push()成对出现
             actionContext.pop();
         }
     }
}</pre>

<p>&nbsp;</p>]]></description>&#xd;
    <en_description><![CDATA[<h1>Action</h1>

<h2>1. Introduction</h2>

<p>&nbsp;&nbsp;&nbsp; The model is data like XML, the data itself cannot be run directly, and the action is to make the model an executable method, so that the dynamic model truly becomes a programming method. </p>

<h2>2. The principle of making the model executable</h2>

<p>&nbsp;&nbsp;&nbsp; The execution principle of the model is in <a href="javascript:invoke('action:xworker.swt.xworker.prototype.ThingRegistSelector/@actions/@utilBrowserSelectThing?thing=xworker.doc.dyanmicmodel. DynamicModel')">Dynamic Model</a> has been introduced in the documentation, and I will explain it in detail here. </p>

<h3>2.1. The model is interpreted and executed</h3>

<p>&nbsp;&nbsp;&nbsp; The model itself is data. When a model is executed, it is actually executing an interpreter program, which can process model data. For example, to execute the code: &quot;return x + y;&quot;, the code itself is data, which can be represented by a model. To make it execute, it is necessary to write a program to interpret and execute this section of &quot;return x + y;&quot; Code. When the interpreter is executed, it is equivalent to &quot;return x&nbsp;+ y;&quot; this code is executed. </p>

<h3>2.2. Loop interpretation and execution</h3>

<p>&nbsp;&nbsp;&nbsp; If you realize that code can be data, and interpreting and executing code data can be equivalent to code execution, then you can design an execution method for any model. </p>

<ol>
<li>First assume that any model is executable. If you want to run a model, you can turn it into an action. The action is actually a method named run (the model is also an object and has its own behavior). </li>
<li>The method whose model name is run is also a model. To run the model with the run method, run its run method as well. </li>
<li>The above is an iterative process. If you want the iteration to be terminated, there are some models that do not need to execute its run method, but are directly interpreted and executed by the engine. </li>
</ol>

<p>&nbsp;&nbsp;&nbsp; The above is the principle of making the model executable. In fact, the execution of any model is iterated to the meta-system (the system that implements the dynamic model). For example, the dynamic model of XWorker is written in Java, which means that it is a Java program, and the final execution is the execution of Java code. </p>

<h3>2.3. Solve the limitations of the action model</h3>

<p>&nbsp;&nbsp;&nbsp; Since the models are ultimately interpreted and executed by the meta-system (the system that implements the dynamic model), there is a question whether the interpreter on the existing meta-system can interpret and execute arbitrary Model? To solve this problem, the following methods can generally be used. </p>

<h4>2.3.1. Writing grammatical action models</h4>

<p>&nbsp;&nbsp;&nbsp; Various grammatical action models can be written. Various grammars of Java can be encapsulated into corresponding action models, such as try/catch, while and other action models. </p>

<p>&nbsp;&nbsp;&nbsp; You can write grammatical action models, which means that you can build new programming languages ​​with models. When you have a programming language written with models, you can theoretically use the model to explain and execute any model. NS. However, in actual programming, it is recommended to use Java to write the action model, which is convenient for debugging and has high performance. </p>

<h4>2.3.2. Use script-like action models</h4>

<p>&nbsp;&nbsp;&nbsp; You can use the script-like action model, and you can run the script through the script-like model, and the script can be written and run at any time. Script models such as Groovy, Js, BeanShell, Lua, etc. </p>

<h3>2.4. Acquisition order of behavior</h3>

<p>&nbsp;&nbsp;&nbsp; Since the behavior of a model object can be defined in the model object itself, it can also be inherited from its class and other objects, so if both itself and the class define actions with the same name, then the object should use specific Which one of them? </p>

<p>&nbsp;&nbsp;&nbsp; The order of obtaining the object behavior is as follows, if it is obtained, it will not be obtained later. </p>

<ol>
<li>Get from self-defined behavior. </li>
<li>Get from the behavior defined by its descriptor (class) itself. </li>
<li>Get from the behavior defined by other objects it inherits. </li>
<li>Acquired from the behavior inherited by its descriptor (class). </li>
<li>Acquired from the behavior inherited from other objects it inherits. </li>
</ol>

<h2>3. The realization of the action</h2>

<p>&nbsp;&nbsp;&nbsp; Use the schematic code to explain how the action is implemented. </p>

<h3>3.1. Convert to action</h3>

<pre class="brush:java;">
import org.xmeta.Action;
import org.xmeta.Thing;

//Thing is the model
Thing thing = ......;

//Action is an action, the model can be transformed into an action
Action action = thing.getAction();</pre>

<p>&nbsp;&nbsp;&nbsp; The schematic code of getAction(). </p>

<pre class="brush:java;">
package org.xmeta;

public class Thing{
     public Action getAction(){
         return new Action(this);
     }
}</pre>

<h3>3.2. Perform actions</h3>

<pre class="brush:java;">
import org.xmeta.ActionContext;

Object result = action.run(new ActionContext());</pre>

<p>&nbsp;&nbsp;&nbsp; You can call the run() method of the action to execute it, which requires the parameter ActionContext, which is the context of the action execution, used to manage the variable stack and thread state, etc. &nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp; The implementation code of the run() method is as follows. </p>

<pre class="brush:java;">
package org.xmeta;

public class Action{
    public Object run(ActionContext actionContext){
        //Model when converted to action
        Thing thing = getThing();
        
        //thingName is the type name of the model
        if(&quot;JavaAction&quot;.equlas(thing.getThingName()){
             //Execute the Java method specified by the model. Here is the end of the iteration
             return javaMethod.invoke(actionContext);
        }else{
             //Get the run method of the model
             Thing runThing = thing.getActionThing(&quot;run&quot;);
             //Convert the run method into action execution. Iterations are formed here
             return runThing.getAction().run(actionContext);
        }
    }
}</pre>

<h2>4. The purpose of the action</h2>

<h3>4.1. Can be used as functions and methods</h3>

<pre class="brush:java;">
import org.xmeta.Action;
import org.xmeta.ActionContext;
import org.xmeta.Thing;

//Get actions from the model
Thing thing = ...;
Action action = thing.getAction();

//Perform an action
ActionContext actionContext = new ActionContext();
Object result = actionContext.run(actionContext);

//Pass the parameter execution, the parameter is passed in by name
Object result = actionContext.run(actionContext, &quot;x&quot;, 1, &quot;y&quot;, 2);
</pre>

<h3>4.2. Can be executed as an object behavior</h3>

<pre class="brush:java;">
import org.xmeta.ActionContext;
import org.xmeta.Thing;

//Get model
Thing thing = ...;

ActionContext actionContext = new ActionContext();

//Execute its behavior
Object result = thing.doAction(&quot;run&quot;, actionContext);

//Perform its behavior, pass in parameters
Object result = thing.doAction(&quot;run&quot;, actionContext, &quot;x&quot;, 1, &quot;y&quot;, 2);</pre>

<p>&nbsp;&nbsp;&nbsp; The principle of executing object behavior is shown in the following code. </p>

<pre class="brush:java;">
import org.xmeta.ActionContext;
import org.xmeta.Thing;

public class Thing{
     public Object doActin(String name, ActionContext actionContext, Object ... params){
         //Get the definition of the action model
         Thing actionThing = getActionThing(name);
         //Convert to action
         Action action = actionThing.getAction();

         //Convert the parameters to Map
         Map&lt;String, Object&gt; paramsMap = UtilMap.toMap(params);
         
         //Create to give variable stack
         Bindings bindings = actionContext.push();
         try{
              //Put the parameters
              bindings.putAll(paramsMap);
              //Put in yourself
              bindings.put(&quot;self&quot;, this);

              //implement
              return action.run(actionContext);
         }finally{
             //Pop up the variable stack and appear in pairs with push()
             actionContext.pop();
         }
     }
}</pre>

<p>&nbsp;</p>]]></en_description>&#xd;
</QuickContent>