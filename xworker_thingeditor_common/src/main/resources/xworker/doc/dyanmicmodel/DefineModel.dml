^1627351773999
@
sname
MetaThingDoc
slabel
定义模型
stype
thingDesc
sgroup
dynamicModel.-10000|defineModel
sgroupDescriptor
true
sicon
icons/html.png
sstyledTextForInsert
parentContext.parentContext.codeText
suseTargetThingDoc
false
ssimpleBrowser
true
shideOutline
false
Sdescription
#$@text#$@
<h1>定义模型</h1>

<h2>1.基本知识</h2>

<h3>1.1.模型的结构</h3>

<p>&nbsp;&nbsp;&nbsp; 动态模型是面向对象的，一个模型可以看成一个对象，一个对象是由属性、子模型（子对象）和行为组成的。</p>

<h3>1.2.定义模型相当于定义模型的类</h3>

<p>&nbsp;&nbsp;&nbsp; 由于模型是对象，因此定义模型就相当于定义它的类，即定义一个模型有哪些属性、子模型和行为等。</p>

<p>&nbsp;&nbsp;&nbsp; 模型的类也是模型，类模型使用它的各种子节点来定义模型的属性、子模型和行为等。</p>

<h3>1.3.动态模型中的面向对象的基本知识</h3>

<h4>1.3.1.模型的每一个节点都是独立的对象</h4>

<p>&nbsp;&nbsp;&nbsp; 在动态模型里一个模型的每一个节点都可以看作是独立的对象。</p>

<h4>1.3.2.模型的属性</h4>

<p>&nbsp;&nbsp;&nbsp; 在运行时一个模型可以设置任意属性，属性是保存在Map&lt;String, Object&gt;中的，属性的值类型没有限制。但在持久化保存时只有定义过的属性才会被保存，并且值要能够被序列化（最好只使用基本类型的数据）。</p>

<h4>1.3.3.模型的行为</h4>

<p>&nbsp;&nbsp;&nbsp; 一个模型的第一个名字为actions的子节点下是它的行为的定义，另外模型的行为也可以继承于它的类，也可以是继承于被继承的模型。寻找一个模型的行为，首先从自身查找，其次是类，然后是继承上查找。</p>

<h4>1.3.4.模型的继承</h4>

<p>&nbsp;&nbsp;&nbsp; 当一个模型继承另一个模型时，只继承行为，不继承属性和子节点。但是当这两个模型都当作类模型使用时，它们所定义的属性和子节点会继承下来的。比如动物有名字属性，人继承动物，那么人也有名字这个属性，此时人的实例张三就有名字属性，名字属性是从动物上继承下来的。</p>

<h4>1.3.5.模型的类</h4>

<p>&nbsp;&nbsp;&nbsp; 一个模型可以以任意模型和任意多个模型作为自己的类，模型继承类模型的行为，并且在持久化保存模型时会保存类模型定义的属性。</p>

<h2>2.定义模型的方法</h2>

<h3>2.1.使用xworker.lang.MetaDescriptor3来编写类模型</h3>

<p>&nbsp;&nbsp;&nbsp; 在动态模型里，理论上任何模型都可以使用已有的模型编辑出来，并且类模型也是模型，所以类模型也可以使用已有的模型编辑出来。在XWorker里一般使用模型xworker.lang.MetaDescriptor3来编写类模型。</p>

<h3>2.2.类模型示例</h3>

<p>&nbsp;&nbsp;&nbsp; 下面的Person模型是一个类模型，它是使用MetaDescriptor3模型编写的。它的actions子节点下是行为的定义，attribute节点是属性的定义，thing节点是子模型的定义，MenuBar是模型菜单的定义。</p>

<pre class="brush:xml;">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;thing name=&quot;Person&quot; descriptors=&quot;xworker.lang.MetaDescriptor3&quot;&gt;
    &lt;actions&gt;
        &lt;GroovyAction name=&quot;sayHello&quot; descriptors=&quot;xworker.lang.actions.GroovyAction&quot; code=&quot;println self.name + &amp;quot; say hello world&amp;quot;;&quot;&gt;&lt;/GroovyAction&gt;
    &lt;/actions&gt;
    &lt;attribute name=&quot;name&quot;&gt;&lt;/attribute&gt;
    &lt;attribute name=&quot;age&quot;&gt;&lt;/attribute&gt;
    &lt;attribute name=&quot;sex&quot; inputtype=&quot;select&quot;&gt;
        &lt;value name=&quot;男&quot; value=&quot;0&quot;&gt;&lt;/value&gt;
        &lt;value name=&quot;女&quot; value=&quot;1&quot;&gt;&lt;/value&gt;
    &lt;/attribute&gt;
    &lt;attribute name=&quot;description&quot; inputtype=&quot;html&quot;&gt;&lt;/attribute&gt;
    &lt;thing name=&quot;Child&quot; extends=&quot;xworker.doc.dyanmicmodel.examples.Person&quot;&gt;&lt;/thing&gt;
    &lt;MenuBar&gt;
        &lt;Menu name=&quot;Person&quot;&gt;
            &lt;ExecuteAction name=&quot;ExecuteAction&quot; label=&quot;Run&quot; actionName=&quot;sayHello&quot;&gt;&lt;/ExecuteAction&gt;
        &lt;/Menu&gt;
    &lt;/MenuBar&gt;
&lt;/thing&gt;</pre>

<h2>3.定义模型的技巧</h2>

<h3>3.1.使用继承定义复杂的模型</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;继承在定义模型时非常有用，可以用来定义复杂的模型。如在上面的模型里Child继承Person模型，所以Child也是一个Person。</p>

<p>&nbsp;&nbsp;&nbsp; 在实际定义模型时，比如在包装Java的API时，可以按照Java实际的类和接口来定义模型，并且也可以按照Java的继承关系定义模型的继承关系，其中Java的接口在模型里也是继承关系。</p>

<h3>3.2.模型编辑器</h3>

<p>&nbsp;&nbsp;&nbsp; 定义模型时，同时可以设置模型的编辑器，主要是设置属性的编辑方式。</p>

<p>&nbsp;&nbsp;&nbsp; 下面是和属性编辑器相关的几个常用属性。</p>

<ul>
	<li><strong>inputtype</strong><br />
	输入方式。XWorker预置一些属性的编辑器，如文本框、HTML编辑器、下拉列表等等。<br />
	&nbsp;</li>
	<li><strong>inputattrs</strong><br />
	输入扩展属性。可以设置和输入方式相关的额外属性。另外它一般还可以提供帮助，当选择一个输入方式后，点击输入扩展属性的*按钮可以弹出帮助或设置界面等。<br />
	&nbsp;</li>
	<li><strong>size</strong><br />
	尺寸。输入控件的大小，一般是宽度。是一个估计值，如60，不是像素值。<br />
	&nbsp;</li>
	<li><strong>group</strong><br />
	分组。同名的属性分到相同的标签页中。<br />
	&nbsp;</li>
	<li><strong>其它</strong><br />
	其它如跨行、跨列等等可以参看它们的文档。</li>
</ul>

<h3>3.3.使用注册</h3>

<h4>3.3.1.模型注册简介</h4>

<p>&nbsp;&nbsp;&nbsp; 模型注册是把一个模型注册到另一个模型下面，注册时可以指定注册的类型。比如把B模型以child(注册类型）方式注册到模型A下，那么通过模型A搜索child的注册时，就可以找到B模型。</p>

<p>&nbsp;&nbsp;&nbsp; 模型注册是一个实用的功能。比如模型注册常用于框架和帮助系统。</p>

<ul>
	<li><strong>框架</strong><br />
	比如第三方可以提供界面控件模型，第三方的控件模型可以以child的方式注册到界面的容器控件下，这样在编写界面添加容器的子控件时，就可以看到并使用第三方的控件了。<br />
	&nbsp;</li>
	<li><strong>文档和示例</strong><br />
	比如可以为某个模型编写文档和示例等，然后注册到该模型下，这样就可以通过这个模型就获取已注册的文档和示例了。</li>
</ul>

<h4>3.3.2.使用模型注册</h4>

<p>&nbsp;&nbsp;&nbsp; 模型注册的本质是一个索引。比如B模型以child的方式注册到A模型，是指在B模型中存在一个注册相关的属性，这个属性的值是&ldquo;child|A&rdquo;。那么通过A如何获取B模型呢？其实就是搜索所有模型，找到注册相关的属性，看看它的值是否有A，比如&ldquo;child|A&rdquo;就表示这个模型是以child的方式注册到A了，那么符合条件。</p>

<p>&nbsp;&nbsp;&nbsp; 要设置模型的注册相关属性，可以在模型编辑器里选择描述者（类）MetaThing来编辑，在Regist标签页中可以看到相关属性。</p>

<p>&nbsp;&nbsp;&nbsp; 由于搜索所有模型是耗时耗内存的任务，所以注册索引通常是缓存到内存中或数据库中的。</p>

<h4>3.3.3.如何搜索注册</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;如下面的示例代码。</p>

<pre class="brush:groovy;">
import org.xmeta.Thing;

import xworker.util.XWorkerUtils;
import xworker.lang.executor.Executor;

//查询注册事物，搜索注册到xworker.lang.actions.Actions上的模型
Thing thingsIndex = world.getThing(&quot;xworker.lang.actions.Actions&quot;);
List&lt;Thing&gt; things = XWorkerUtils.searchRegistThings(thingsIndex, &quot;child&quot;, [], actionContext);
</pre>

<h2>&nbsp;</h2>

<p>&nbsp;</p>

<p>&nbsp;</p>
#$@text#$@
sen_label
Define Model
sdescriptors
xworker.content.QuickContent
sinheritDescription
false
sth_createIndex
true
sth_registThing
child|xworker.example.ExamplesIndex
sth_registMyChilds
false
sth_registDisabled
false
sth_noThingRegistViewer
false
sth_fileMonitor
false
sth_deprecated
false
Sen_description
#$@text#$@
<h1>Define the model</h1>

<h2>1. Basic knowledge</h2>

<h3>1.1. The structure of the model</h3>

<p>&nbsp;&nbsp;&nbsp; The dynamic model is object-oriented, a model can be regarded as an object, and an object is composed of attributes, sub-models (sub-objects) and behaviors. </p>

<h3>1.2. Defining the model is equivalent to defining the class of the model</h3>

<p>&nbsp;&nbsp;&nbsp; Since a model is an object, defining a model is equivalent to defining its class, that is, defining what attributes, submodels, and behaviors a model has. </p>

<p>&nbsp;&nbsp;&nbsp; The class of a model is also a model. The class model uses its various sub-nodes to define the attributes, sub-models, and behaviors of the model. </p>

<h3>1.3. Basic object-oriented knowledge in dynamic models</h3>

<h4>1.3.1. Each node of the model is an independent object</h4>

<p>&nbsp;&nbsp;&nbsp; In a dynamic model, each node of a model can be regarded as an independent object. </p>

<h4>1.3.2. Attributes of the model</h4>

<p>&nbsp;&nbsp;&nbsp; A model can set any attributes at runtime. The attributes are stored in Map&lt;String, Object&gt;, and there is no restriction on the value type of the attribute. However, only the defined properties will be saved when persisting, and the value must be able to be serialized (it is best to use only basic types of data). </p>

<h4>1.3.3. Model behavior</h4>

<p>&nbsp;&nbsp;&nbsp; The first child node of a model named actions is the definition of its behavior. In addition, the behavior of the model can also be inherited from its class or inherited model. . To find the behavior of a model, first look up from itself, secondly from class, and then from inheritance. </p>

<h4>1.3.4. Model inheritance</h4>

<p>&nbsp;&nbsp;&nbsp; When a model inherits another model, only the behavior is inherited, not attributes and child nodes. But when these two models are used as class models, the attributes and child nodes they define will be inherited. For example, animals have the attribute of names, and humans inherit the attribute of animals, so people also have the attribute of names. At this time, the instance of human Zhang San has the attribute of names, and the attribute of names is inherited from animals. </p>

<h4>1.3.5. Model class</h4>

<p>&nbsp;&nbsp;&nbsp; A model can take any model and any number of models as its own class. The model inherits the behavior of the class model and saves the attributes defined by the class model when the model is persisted. </p>

<h2>2. How to define the model</h2>

<h3>2.1. Use xworker.lang.MetaDescriptor3 to write the class model</h3>

<p>&nbsp;&nbsp;&nbsp; In the dynamic model, in theory, any model can be edited using an existing model, and the class model is also a model, so the class model can also be edited using the existing model. In XWorker, the model xworker.lang.MetaDescriptor3 is generally used to write class models. </p>

<h3>2.2. Class model example</h3>

<p>&nbsp;&nbsp;&nbsp; The Person model below is a class model, which is written using the MetaDescriptor3 model. Its actions sub-node is the definition of behavior, the attribute node is the definition of the attribute, the thing node is the definition of the sub-model, and MenuBar is the definition of the model menu. </p>

<pre class="brush:xml;">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;thing name=&quot;Person&quot; descriptors=&quot;xworker.lang.MetaDescriptor3&quot;&gt;
    &lt;actions&gt;
        &lt;GroovyAction name=&quot;sayHello&quot; descriptors=&quot;xworker.lang.actions.GroovyAction&quot; code=&quot;println self.name + &amp;quot; say hello world&amp;quot;;&quot;&gt;&lt;/GroovyAction&gt;
    &lt;/actions&gt;
    &lt;attribute name=&quot;name&quot;&gt;&lt;/attribute&gt;
    &lt;attribute name=&quot;age&quot;&gt;&lt;/attribute&gt;
    &lt;attribute name=&quot;sex&quot; inputtype=&quot;select&quot;&gt;
        &lt;value name=&quot;Male&quot; value=&quot;0&quot;&gt;&lt;/value&gt;
        &lt;value name=&quot;female&quot; value=&quot;1&quot;&gt;&lt;/value&gt;
    &lt;/attribute&gt;
    &lt;attribute name=&quot;description&quot; inputtype=&quot;html&quot;&gt;&lt;/attribute&gt;
    &lt;thing name=&quot;Child&quot; extends=&quot;xworker.doc.dyanmicmodel.examples.Person&quot;&gt;&lt;/thing&gt;
    &lt;MenuBar&gt;
        &lt;Menu name=&quot;Person&quot;&gt;
            &lt;ExecuteAction name=&quot;ExecuteAction&quot; label=&quot;Run&quot; actionName=&quot;sayHello&quot;&gt;&lt;/ExecuteAction&gt;
        &lt;/Menu&gt;
    &lt;/MenuBar&gt;
&lt;/thing&gt;</pre>

<h2>3. Skills for defining models</h2>

<h3>3.1. Use inheritance to define complex models</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Inheritance is very useful when defining models, and can be used to define complex models. For example, in the above model, Child inherits the Person model, so Child is also a Person. </p>

<p>&nbsp;&nbsp;&nbsp; When the model is actually defined, for example, when packaging the Java API, the model can be defined in accordance with the actual Java classes and interfaces, and the inheritance relationship of the model can also be defined in accordance with the inheritance relationship of Java. Java's interface is also inherited in the model. </p>

<h3>3.2. Model Editor</h3>

<p>&nbsp;&nbsp;&nbsp; When defining the model, you can also set the editor of the model, mainly to set the editing method of the attributes. </p>

<p>&nbsp;&nbsp;&nbsp; Here are a few commonly used attributes related to the attribute editor. </p>

<ul>
<li><strong>inputtype</strong><br />
	input method. XWorker presets some attribute editors, such as text boxes, HTML editors, drop-down lists, and so on. <br />
&nbsp;</li>
<li><strong>inputattrs</strong><br />
Enter extended attributes. You can set additional attributes related to the input method. In addition, it can generally provide help. After selecting an input method, click the * button to enter the extended attributes to pop up the help or setting interface. <br />
&nbsp;</li>
<li><strong>size</strong><br />
	size. The size of the input control, generally the width. It is an estimated value, such as 60, not a pixel value. <br />
&nbsp;</li>
<li><strong>group</strong><br />
Grouping. The attributes with the same name are grouped into the same tab page. <br />
&nbsp;</li>
<li><strong>Other</strong><br />
Others such as cross-row, cross-column, etc. can refer to their documents. </li>
</ul>

<h3>3.3. Use registration</h3>

<h4>3.3.1. Introduction to model registration</h4>

<p>&nbsp;&nbsp;&nbsp; Model registration is to register a model under another model. The type of registration can be specified when registering. For example, if model B is registered under model A as child (registration type), then model B can be found when the child's registration is searched through model A. </p>

<p>&nbsp;&nbsp;&nbsp; Model registration is a useful feature. For example, model registration is often used in frameworks and help systems. </p>

<ul>
<li><strong>Frame</strong><br />
For example, a third party can provide an interface control model, and the third-party control model can be registered under the container control of the interface in a child manner, so that you can see and use the third-party control when writing the interface to add the child control of the container. <br />
&nbsp;</li>
<li><strong>Documents and examples</strong><br />
For example, you can write documents and examples for a model, and then register to the model, so that you can get the registered documents and examples through this model. </li>
</ul>

<h4>3.3.2. Use model registration</h4>

<p>&nbsp;&nbsp;&nbsp; The essence of model registration is an index. For example, the B model is registered to the A model in a child manner, which means that there is a registration related attribute in the B model, and the value of this attribute is &ldquo;child|A&rdquo;. So how to get the B model through A? In fact, it is to search all models, find the attributes related to the registration, and see if its value has A. For example, "child|A" means that the model is registered to A in a child manner, and it meets the conditions. </p>

<p>&nbsp;&nbsp;&nbsp; To set the registration related properties of the model, you can select the descriptor (class) MetaThing in the model editor to edit, and you can see the related properties in the Regist tab. </p>

<p>&nbsp;&nbsp;&nbsp; Since searching all models is a time-consuming and memory-consuming task, the registration index is usually cached in memory or in the database. </p>

<h4>3.3.3. How to search for registration</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Such as the sample code below. </p>

<pre class="brush:groovy;">
import org.xmeta.Thing;

import xworker.util.XWorkerUtils;
import xworker.lang.executor.Executor;

//Query registered things, search for models registered on xworker.lang.actions.Actions
Thing thingsIndex = world.getThing(&quot;xworker.lang.actions.Actions&quot;);
List&lt;Thing&gt; things = XWorkerUtils.searchRegistThings(thingsIndex, &quot;child&quot;, [], actionContext);
</pre>

<h2>&nbsp;</h2>

<p>&nbsp;</p>

<p>&nbsp;</p>
#$@text#$@
sth_mark
false
sth_registQueryOnlySelf
false
