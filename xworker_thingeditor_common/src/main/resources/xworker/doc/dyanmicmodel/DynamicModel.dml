^1629875989383
@
sname
DynamicModel
slabel
动态模型
stype
thingDesc
sgroup
dynamicModel
sgroupDescriptor
true
sicon
icons/html.png
sth_sortWeight
-9000
sstyledTextForInsert
parentContext.parentContext.codeText
suseTargetThingDoc
false
ssimpleBrowser
true
shideOutline
false
Sdescription
#$@text#$@
<h1>动态模型</h1>

<h2>1.基本概念</h2>

<p>&nbsp;&nbsp;&nbsp; 动态模型是一种面向对象的编程方法，它使用结构化的数据来编程，这些结构化的数据可以用XML来表示，也可以简单的理解为可以使用XML来编程。</p>

<p>&nbsp; &nbsp; 如下面的XMl就是一个动态模型的程序。</p>

<pre class="brush:xml;">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Shell name=&quot;shell&quot; descriptors=&quot;xworker.swt.widgets.Shell&quot; text=&quot;TestShell&quot;&gt;
    &lt;FillLayout name=&quot;FillLayout&quot;&gt;&lt;/FillLayout&gt;
    &lt;Browser name=&quot;Browser&quot; url=&quot;https://www.xworker.org&quot;&gt;&lt;/Browser&gt;
    &lt;GroovyAction name=&quot;init&quot;  code=&quot;println &amp;quot;Hello World!&amp;quot;;&quot;&gt;&lt;/GroovyAction&gt;
&lt;/Shell&gt;</pre>

<h2>2.动态模型的特点</h2>

<ul>
	<li><strong>动态编程</strong><br />
	动态模型是一种面向对象的编程方法，它可以在系统运行时动态修改系统中的类和对象，并且修改后的类和对象也能够被实时解释执行，因此可以实现运行时的动态编程。<br />
	&nbsp;</li>
	<li><strong>快速编程</strong><br />
	动态模型的编程方法多种多样，可以针对不同的模型可以编写不同的编程工具，在使用动态模型编程的过程中，也可以不断的编写工具来优化自己，从而能够让编程能够越来越快捷。<br />
	&nbsp;&nbsp;&nbsp;</li>
	<li><strong>积累和迭代</strong><br />
	动态模型一般在系统运行时动态编程，此时应用和模型编程工具是同一个系统，这样新开发出来的模型总是会自动成为系统的一部分，这样可以很容易的实现系统的积累和迭代。</li>
</ul>

<h2>3.动态模型是如何实现的？</h2>

<p style="margin: 0px 0px 10px;">&nbsp; &nbsp; 动态模型使用结构化的数据编程，它有两个核心问题。</p>

<ol>
	<li><strong>如何用数据表示各种东西</strong><br />
	动态模型采用的是面向对象的方法。<br />
	&nbsp;</li>
	<li><strong>如何让数据变成可执行的程序</strong><br />
	动态模型采取的是迭代解释执行的方法。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp; 具体可以参看动态模型的原理。</p>

<p>&nbsp;&nbsp;</p>
#$@text#$@
sen_label
Dynamic Model
sdescriptors
xworker.content.QuickContent
sinheritDescription
false
sth_createIndex
true
sth_registThing
child|xworker.example.ExamplesIndex
sth_registMyChilds
false
sth_registDisabled
false
sth_noThingRegistViewer
false
sth_fileMonitor
false
Sen_description
#$@text#$@
<h1>Dynamic Model</h1>

<p>&nbsp; &nbsp; &nbsp;This paper introduces the basic concepts and methods of dynamic model programming.</p>

<h2>1.Introduction to dynamic model</h2>

<h3>1.1.Using structured data to represent objects</h3>

<p>&nbsp; &nbsp; Dynamic model uses structured data to represent objects, so objects are data in the system, which can be represented by XML.</p>

<p>&nbsp; &nbsp; For example, the following XML is a dynamic model program.</p>

<pre class="brush:xml;">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;Shell name=&quot;shell&quot; descriptors=&quot;xworker.swt.widgets.Shell&quot; text=&quot;TestShell&quot;&gt;
    &lt;FillLayout name=&quot;FillLayout&quot;&gt;&lt;/FillLayout&gt;
    &lt;Browser name=&quot;Browser&quot; url=&quot;https://www.xworker.org&quot;&gt;&lt;/Browser&gt;
    &lt;GroovyAction name=&quot;init&quot;  code=&quot;println &amp;quot;Hello World!&amp;quot;;&quot;&gt;&lt;/GroovyAction&gt;
&lt;/Shell&gt;</pre>

<h3>1.2.Dynamic object oriented programming method</h3>

<p>&nbsp; &nbsp; In the dynamic model, classes are also common objects, and objects are structured data, so classes and objects can be created and modified at any time when the system is running.</p>

<h2>2.Principle of dynamic model</h2>

<h3>2.1.The role of data</h3>

<p>&nbsp; &nbsp; A data is used according to its role. Dynamic model realizes object-oriented programming by giving data different roles.</p>

<h3>2.2.Principle</h3>

<p>&nbsp; &nbsp; The core of the principle of dynamic model is to assume first and then realize. In short, it is assumed that data can be used to represent all kinds of things, for example, data can represent actions that can be run (acting on methods and functions), and then use these assumptions to define concepts such as objects, and finally how to execute methods.</p>

<h4>2.2.1.Models and things</h4>

<p>&nbsp; &nbsp; Dynamic models think that data can be used to represent all kinds of things, so sometimes we call these data models or things.</p>

<p>&nbsp; &nbsp; In a dynamic model, data can be represented by XML, and an XML node is composed of attributes and sub nodes, so a model or thing is composed of attributes and sub nodes (sub models or sub things).</p>

<h4>2.2.2.Action</h4>

<p>&nbsp; &nbsp; Dynamic model considers that any model can be transformed into actions,&nbsp;in which action&nbsp;can be executed, and actions&nbsp;are equivalent to methods and functions.</p>

<h4>2.2.3.Object</h4>

<p>&nbsp; &nbsp; Since a model can contain attributes and sub models (the definition of 2.2.1.) and any model can execute (the assumption of 2.2.2), some sub nodes of a model can be regarded as its behavior, so a model can be regarded as an object.</p>

<p>&nbsp; &nbsp; Actions are equivalent to methods and functions. When an action belongs to an object and the object can call the action, the action can be regarded as the behavior of the object.</p>

<h4>2.2.4.Descriptor</h4>

<p>&nbsp; &nbsp; A descriptor is a model used to describe a model. A descriptor can also be regarded as the&nbsp;class of a model, which is used to describe the structure and behavior of a model. In a dynamic model, the descriptor of a model can be any model, and the model inherits the behavior of the descriptor.</p>

<h4>2.2.5.Extend</h4>

<p>&nbsp; &nbsp; In a dynamic model, a model can inherit any model except itself, thus inheriting the behavior of the inherited model.</p>

<h3>2.3.Object-oriented</h3>

<p>&nbsp; &nbsp; In the dynamic model, by assigning various roles to the data, the dynamic model actually realizes the object-oriented programming method.</p>

<h2>3.Realization of dynamic model</h2>

<p>&nbsp; &nbsp; The core of implementing dynamic model programming is how to explain and execute a model.</p>

<ol>
	<li>In 2.2.2. Above, it is assumed that any model can be transformed into actions to execute. The specific method is to take the model as the object and execute the run method of the object.</li>
	<li>The run method of the model is still the model (see 2.2.3, using the child nodes of the model to define the behavior of the model), so execute the run method and go back to step 1.</li>
	<li>The above is a recursive method. If you want the recursion to terminate, some models are executed directly by the engine.</li>
</ol>

<p>&nbsp; &nbsp; The above is how to execute a model. For example, xworker&#39;s dynamic model engine is implemented in Java, and the model named JavaAction is directly executed by the engine, that is, the engine directly interprets and executes the JavaAction instead of executing its run method.</p>

<pre class="brush:xml;">
&lt;JavaAction name=&quot;run&quot; useOuterJava=&quot;true&quot; outerClassName=&quot;test.HelloWorld&quot; methodName=&quot;run&quot;/&gt;</pre>

<p>&nbsp; &nbsp; For example, when the above model (XML) is executed, it does not need to execute its run method. It is executed directly by the engine, and the engine will execute Java classes according to its attribute definition test.HelloWorld The run () method of.</p>

<h2>4.Common API of engine&nbsp; &nbsp;</h2>

<h4>4.1.Initialize engine</h4>

<p>&nbsp; &nbsp; The model engine can be initialized through the world class. The path parameter is the directory of the model application, which is generally the working directory of the engine. The directory can contain class library, model library and generated temporary files.</p>

<pre class="brush:java;">
import org.xmeta.World;

World world = World.getInstance();
world.init(&quot;.&quot;);</pre>

<h4>4.2.Get model</h4>

<p>&nbsp; &nbsp; You can get a model through the path of the model. The path rules of the model are basically the same as those of the Java class name, but the path of the model can also contain the path of the child node. as test.HelloWorldModel Is the path to the descriptor model.</p>

<pre class="brush:java;">
import org.xmeta.Thing;

//Get descriptor model
Thing thing = world.getThing(&quot;test.HelloWorldModel&quot;);</pre>

<h4>4.3.As an API related to structured data</h4>

<pre class="brush:java;">
//Gets the value of a property
Object value = thing.get(&quot;name&quot;);

//Sets the value of a property
thing.set(&quot;name&quot;, &quot;Hello World&quot;);

//Get the value of a property and convert it to the corresponding type, support the conversion of common types
//The general method is geTx (Stirng name), where x is the corresponding type
int age = thing.getInt(&quot;age&quot;);  

//Gets the child nodes
List&lt;Thing&gt; childs = thing.getChilds();</pre>

<h4>4.4.Actions and behaviors</h4>

<p>&nbsp; &nbsp; Convert model to action</p>

<pre class="brush:as3;">
import org.xmeta.Thing;
import org.xmeta.Aciton;
import org.xmeta.ActionContext;

//Get the HelloWorldExample model
Thing helloWorldExample = world.getThing(&quot;test.HelloWorldExample&quot;);

//Convert to action, compare with Java, action is similar to static method
Action helloWorldAction = helloWorldExample .getAction();

//Execution action
//ActionContext is needed when actions and objects are executed. Action context is used to manage variables and thread states
helloWorldAction.run(new ActionContext());</pre>

<p>&nbsp; &nbsp; Take the model as an object and execute its behavior</p>

<pre class="brush:java;">
import org.xmeta.Thing; 
import org.xmeta.ActionContext;

//Get the HelloWorldExample model
Thing helloWorldExample = world.getThing(&quot;test.HelloWorldExample&quot;);
//Execute the run method of HelloWorld example.
//When executing an object&#39;s behavior, the object itself will be put into the action context with the variable name self (equivalent to this variable), and the action can access the object model through the self variable.
helloWorldExample.doAction(&quot;run&quot;, new ActionContext());
</pre>

<p>&nbsp; &nbsp; The method of transferring parameters is also applicable to action execution.</p>

<pre class="brush:java;">
//Pass parameter, method 1, parameter name + parameter value, can set multiple, parameter name and parameter value appear in pairs
Object result = thing.doAction(&quot;xxx&quot;, new ActionContext(), &quot;p1&quot;, p1Value,  &quot;p2&quot;, p2Value...);

//Pass parameters, method 2, set parameters through actioncontext
ActionContext actionContext = new ActionContext();
actionContext.peek().put(&quot;p1&quot;, p1Value);
actionContext.peek().put(&quot;p2&quot;, p2Value);
......
Object result = thing.doAction(&quot;xxx&quot;, actionContext);
</pre>

<p>&nbsp; &nbsp;The difference between action and behavior is that when an action is executed, the model does not pass itself into the action context as a self variable, but it does when it is executed as an object. Therefore, when an action is executed, there is no self variable (or the self variable is not itself), while when an object&#39;s behavior is executed, the self variable is the object model itself.</p>

<p>&nbsp; &nbsp; For example, in the following code, the self variable is the HelloWorld example model itself when executing the run behavior of the HelloWorld example model object.</p>

<pre class="brush:java;">
    public static void run(ActionContext actionContext){
        //Model instance, equivalent to the role of Java&#39;s this variable
        Thing self = actionContext.getObject(&quot;self&quot;);
 
        System.out.println(self.getString(&quot;message&quot;));
    }</pre>

<h4>4.5Object oriented method</h4>

<pre class="brush:java;">
//Get the primary descriptor (class)
Thing descriptor = thing.getDescriptor();

//Get all descriptors (classes)
List&lt;Thing&gt; descriptors = thing.getDescriptors();

//Get the object name, which is equivalent to Java object.getClass().getSimpleName()
String thingName = thing.getThingName();

//Get inheritance list
List&lt;Thing&gt; extends = thing.getExtends();

//Get action list
List&lt;Thing&gt; actions = thing.getActionThings();</pre>

<p>&nbsp;&nbsp;</p>
#$@text#$@
sth_mark
false
sth_registQueryOnlySelf
false
