^1448006501836
@
sname
XWorkerDemoMixMenu
slabel
XWorkerDemoMixMenu
sdescriptors
xworker.swt.xwidgets.DemoMixMenu
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials
sname
XWorkerTutorials
slabel
XWorker指南
sdescription
<p>如何使用XWorker的指南。</p>
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@Node
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@Functions
sname
Functions
slabel
功能简介
sdescription
<p>XWorker的主要功能简介。</p>
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@Node
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@Functions/@Programing
sname
Programing
slabel
编程
stype
description
Sdescription
#$@text#$@
<h3>使用XWorker可以编程</h3>

<ul>
	<li><strong>XWorker是一个编程平台</strong><br />
	XWorker是一个编程平台，在XWorker中可以编写各种应用。<br />
	&nbsp;</li>
	<li><strong>XWorker使用模型编程</strong><br />
	模型是类似于XML或JSON这样的数据，XWorker使用模型编程。<br />
	&nbsp;</li>
	<li><strong>模型编程是实时动态的编程</strong><br />
	XWorker实时解释执行模型，在运行时模型也可以随时改变，模型编程时实时动态的。</li>
</ul>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@Functions/@Application
sname
Application
slabel
应用
stype
description
Sdescription
#$@text#$@
<h3>XWorker还是一个应用平台</h3>

<ul>
	<li><strong>使用XWorker编写的程序属于XWorker的一部分</strong><br />
	和其他编程平台不同，在XWorker中编写的程序仍然可以在XWorker中运行，所以任何在XWorker中编写的程序都自然的属于XWorker本身。<br />
	&nbsp;</li>
	<li><strong>通过积累实现应用的平台</strong><br />
	由于编写的程序自动属于XWorker的一部分，所以在XWorker编程越多，XWorker的功能也就越丰富，所以XWorker最终会成为一个应用平台。</li>
</ul>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials
sname
ProgramTutorials
slabel
编程入门
sdescription
<p>介绍使用XWorker编程的基本知识。</p>
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@Node
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@Objective
sname
Objective
slabel
XWorker的目标
stype
description
Sdescription
#$@text#$@
<h1>XWorker的目标</h1>

<h2>1.&nbsp;智能管家</h2>

<p>&nbsp; &nbsp; 如果你看过《钢铁侠》，那么你一定知道贾维斯，贾维斯是钢铁侠的智能管家，超智能软件，能独立思考，会帮助主人处理各种事务，计算各种信息，钢铁侠的机甲开发以及方舟反应炉的更新都离不开它的协助。</p>

<p>&nbsp; &nbsp; 不过以当前的情况看来，贾维斯这样的智能系统只能是一个还不可以实现梦想，不过我们可以退而求其次，去制作一个理论上可以不关机且动能却可以无限添加的系统。</p>

<h2>2. 为什么要追求一个理论上可以不关机且动能却可以无限添加的系统？</h2>

<h3>2.1 进化</h3>

<p>&nbsp; &nbsp; 从进化论的角度考虑的，如果一个系统可以在运行时不断的加入新的功能，那么它就是一个可以不断修改自己，并且随时都在进化的系统。</p>

<h3>2.2 可能性</h3>

<p>&nbsp; &nbsp; 如果一个系统可以不断地加入新的功能，也许有一天它就变成智能的也说不定，至少它的功能越来越多，作为工具也是很好的。</p>

<h2>3 实时编程系统</h2>

<p>&nbsp; &nbsp; 理论上可以不关机且动能却可以无限添加的系统应该具备哪些特点呢，我想应该是：</p>

<ul>
	<li><strong>在运行中编程</strong><br />
	如果一个系统在理论上是不用关机的，那么如果想要增加或修改系统中的功能，就不能把它停下来更新程序，而是在运行中完成程序的更新，这就要求能够在运行中编程。<br />
	&nbsp;</li>
	<li><strong>在运行时理论上能够无限的加入新功能</strong><br />
	这实际上是理论上永不关机系统应该具备的功能。</li>
</ul>

<p>&nbsp; &nbsp; 具备这两点的系统，我们称为可以实时编程的系统。</p>

<h2>4 XWorker是一个实时编程的系统</h2>

<p>&nbsp; &nbsp; XWorker就是这样的一个实时编程系统，虽然现实中我们要经常重启它，但在编程的理论上它是接近于可以永不用停机就可以增加新功能的系统了。</p>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@modelPrograming
sname
modelPrograming
slabel
实时编程
stype
description
Sdescription
#$@text#$@
<h1>XWorker是一个实时的编程平台</h1>

<h2>1. 软件需求变更</h2>

<p>&nbsp;&nbsp;&nbsp; 软件是围绕需求而开发的，开发一个软件，需要经过需求分析、设计、代码编写、测试和部署等流程，而当需求变更时可能还要重复这些步骤，因此当一个需求是频繁变更时，软件的开发就非常困难。</p>

<p>&nbsp;&nbsp;&nbsp; 反过来看看现实世界，如果把现实世界看作一个程序系统，你可以发现显示世界中的事物是无时无刻都在发生变化的，那么当现实世界中的事物发生变化时，需要重新设计、编码、部署和重新运行么？我认为不需要。</p>

<p>&nbsp;&nbsp;&nbsp; 所以解决软件需求的变更可以模仿现实世界这个系统，因为任何需求都可以随时在运行时修改，这就要求实现一个能够实时编程的平台，这个平台首先是运行的，其次是在这个平台里可以随时增加、减少和修改任何功能。</p>

<h2>2. X-Meta引擎和XWorker</h2>

<p>&nbsp;&nbsp;&nbsp; X-Meta引擎就是一个这样的实时的编程引擎，在X-Meta引擎中每一个事物是一个模型，系统的功能是通过X-Meta引擎解释执行事物模型呈现出来的，并且事物模型是可以随时增加、减少和修改的，这样系统的功能就可以随时增加和修改。</p>

<p>&nbsp; &nbsp; 由于系统的功能主要是通过解释模型呈现的，所以系统的功能主要是由模型决定的，所以系统中有哪些模型就决定了这个系统是什么样功能的系统。</p>

<p>&nbsp;&nbsp;&nbsp; XWorker就是这样的由各种各样的模型组成的一个平台，它依然是由X-Meta引擎解释执行的，它的主要功能是管理事物模型，所以在X-Meta运行时可以增加和修改事物模型，从而XWorker也是一个实时的编程平台。</p>

<h2>3. X-Meta引擎的基本原理</h2>

<p>&nbsp;&nbsp;&nbsp; X-Meta引擎的基本原理主要有两点：</p>

<ul>
	<li><strong>模型是内存中的数据</strong><br />
	由于X-Meta引擎在编程时是运行中的状态，所以它的代码（就是模型）是在内存中的数据。<br />
	&nbsp;</li>
	<li><strong>模型是实时解释执行的</strong><br />
	体现在模型可以随时改变，而当模型改变时在下次使用它时就会立即生效。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp; 下面是X-Meta引擎的原理详细分析。</p>

<h2>4. 模型是内存中的数据</h2>

<p>&nbsp;&nbsp;&nbsp; 下面要将讲述的是模型的结构、模型的持久化、模型的读取和保存，模型的修改和编辑等。</p>

<h3>４.1 模型的结构</h3>

<p>&nbsp;&nbsp;&nbsp; 模型是树形结构的数据，它是有节点组成的，一个节点可以包含任意个属性，也可以包含任意多个子节点。</p>

<p>&nbsp;&nbsp;&nbsp; 模型的结构和XML或JSON类似，因此可以通过XML或JSON来了解模型的结构。比如：</p>

<pre style="margin-left:40px">
&lt;Shell name=&quot;HelloWorld&quot; descriptors=&quot;xworker.swt.widgets.Shell&quot; text=&quot;Hello World&quot; RESIZE=&quot;true&quot; width=&quot;800&quot; height=&quot;600&quot; label=&quot;HelloWorld&quot;&gt;
    &lt;FillLayout&gt;&lt;/FillLayout&gt;
    &lt;Browser url=&quot;http://www.baidu.com&quot; WEBKIT=&quot;true&quot;&gt;&lt;/Browser&gt;
&lt;/Shell&gt;</pre>

<h3>4.2 模型的持久化</h3>

<p>&nbsp;&nbsp;&nbsp; XWorker是实时解释的模型引擎，模型是内存中的数据，如果不把模型持久化保存，那么当系统重启时模型也会丢失，因此需要持久化模型的方法。</p>

<h4>4.2.1 模型可以用多种格式存储</h4>

<p>&nbsp;&nbsp;&nbsp; 模型的结构是树形结构，和XML或JSON类似，因此模型可以以XML或JSON的格式存储。</p>

<p>&nbsp;&nbsp;&nbsp; 除此之外还可以用更多格式存储事物，目前典型的是xer.txt格式，而xml和json只是可选的存储格式。</p>

<p>&nbsp;&nbsp;&nbsp; 另外还可以实现自定义的格式，只要实现模型的相应的编码和解码的接口。</p>

<h4>4.2.2 模型可以存储到多种地方</h4>

<p>&nbsp;&nbsp;&nbsp; 通过存储和读取模型的接口可以实现自定义的模型存储位置，目前已实现把模型存储到文件系统、数据库系统、Java类库和内存中等。</p>

<h3>4.3 模型的读取和保存机制</h3>

<p>&nbsp;&nbsp;&nbsp; 在XWorker中模型是内存中的数据，因此在系统启动时在需要模型会加载到内存中，不再使用的模型可能会从缓存中清除，当再次需要时又会从存储中读入到内存中。</p>

<p>&nbsp;&nbsp;&nbsp; 模型不是自动保存的，在运行时可以调用保存模型的接口保存模型，比如在编辑器中按Ctrl + S保存。</p>

<h3>4.4 模型的修改和编辑</h3>

<p>&nbsp;&nbsp;&nbsp; 模型是内存中的数据，可以在运行时创建和修改，XWorker提供了一个事物（模型）管理器的应用来管理模型，使用它可以创建、编辑和移除事物等。</p>

<p>&nbsp;&nbsp;&nbsp; 事物管理器也是用模型编写的，所以它和使用它被编写的模型一样都是平台中的模型，使用事物管理器也可以随时修改构成它自身的那些模型。</p>

<h2>5. 模型是实时解释执行的</h2>

<p>&nbsp;&nbsp;&nbsp; X-Meta引擎负责解释执行模型，当一个模型发生改变时，X-Meta对这个模型的解释也会发生变化。对模型的实时解释主要体现下面三个方面：</p>

<ul>
	<li><strong>模型是随时可变的</strong><br />
	模型是内存中的数据，它是随时可变的。<br />
	&nbsp;</li>
	<li><strong>是什么？</strong><br />
	即一个模型代表的是什么东西的解释。<br />
	&nbsp;</li>
	<li><strong>执行效果</strong><br />
	模型是可以通过X-Meta引擎解释执行的，当模型发生变化时，它的执行结果也会发生变化。</li>
</ul>

<h3>5.1 模型是可以随时改变的</h3>

<p>&nbsp;&nbsp;&nbsp; 模型是内存中的数据，允许模型在任何时候都可以被创建、修改和删除等。</p>

<h3>5.2 模型是什么也可以可变的</h3>

<p>&nbsp;&nbsp;&nbsp; X-Meta引擎是一个解释引擎，因此当模型修改后，对模型的解释也会发生变化。</p>

<h4>5.2.1 如何说一个模型是什么？</h4>

<p>&nbsp;&nbsp;&nbsp; 当我们使用模型编程时，是用它来表示各种东西，因此需要有一个方法来指明一个模型到底是什么。</p>

<p>&nbsp;&nbsp;&nbsp; 说明一个模型是什么，主要有两种方法，一是通过模型名为name（名字）的属性，另一个是通过模型的描述者（类名）。</p>

<h5>5.2.1.1 通过名为name的属性来说一个事物是什么</h5>

<p>&nbsp;&nbsp;&nbsp; 我们知道每个人都有一个名字，比如他叫张三，我们可以说他是张三，因此我们也可以用同样的方法说一个事物是什么。</p>

<p>&nbsp;&nbsp;&nbsp; 一个模型可以包含多个属性，我们用模型中名为name属性来说明它是什么，比如一个模型是&lt;Person name=&quot;Tom&quot;/&gt;，那么就可以说这个模型是Tom。</p>

<h5>5.2.1.2 通过模型的描述者来说明一个事物是什么</h5>

<p>&nbsp;&nbsp;&nbsp; 在现实中我们也用类名来解释一个事物是什么，比如张三是一个人，那么我们可以说它是人，或说张三是一个人。</p>

<p>&nbsp;&nbsp;&nbsp; 同样，在X-Meta引擎中我们使用描述者来说明一个事物是什么。</p>

<p>&nbsp;&nbsp;&nbsp; <strong>描述者：</strong>在X-Meta引擎中有一个概念叫做描述者，描述者其实相当于类，它是模型之间的关系，可以把一个模型当作另一个模型的描述者。</p>

<h4>5.2.2 一个模型是什么是可变的</h4>

<p>&nbsp;&nbsp;&nbsp; 在X-Meta引擎里，模型的name（名字）和模型的描述者的关系是用模型的属性表示的，而模型是随时可以改变的，因此这两个属性也是可变的，当这些属性发生改变时，对于模型的解释也跟着发生变化。</p>

<p>&nbsp;&nbsp;&nbsp; 比如一个模型先是用&lsquo;人&rsquo;来描述，那么它是一个&lsquo;人&rsquo;，现在改变描述关系的属性把它设置为&lsquo;木头人&rsquo;，那么它就是一个&lsquo;木头人&rsquo;了。</p>

<p>5.3 模型的执行效果也是可变的</p>

<p>&nbsp;&nbsp;&nbsp; 模型是用于编程的，它应该是可以执行的，在X-Meta引擎中方法和函数也是使用模型表示的，这里模型通常称为动作模型，当动作模型发生改变时，对它们的解释也是实时改变的。</p>

<h4>5.3.1 动作模型</h4>

<p>&nbsp;&nbsp;&nbsp; 在X-Meta引擎中动作模型是一类可以执行的模型，它们相当于编程中代码。</p>

<p>&nbsp;&nbsp;&nbsp; 通常动作模型是对代码的引用，比如JavaAction模型就是对Java代码的引用，GroovyAction就是对Groovy代码的引用。</p>

<h4>5.3.2 模型修改后动作的执行也会发生变化</h4>

<p>&nbsp;&nbsp;&nbsp; 首先动作模型也是模型，它可以在运行时随时改变，比如一个JavaAction本来引用的是A方法，现在改成了引用B方法，那么在解释执行时就会实时改变。</p>

<p>&nbsp;&nbsp;&nbsp; 在XWorker中一些动作模型允许直接编写代码，当这些模型发生改变时，会重新编译和装载新的代码。</p>

<p>&nbsp;&nbsp;&nbsp; 因此动作模型发生改变时，它们的执行也会发生改变。</p>

<h2>6. 总结</h2>

<h3>6.1 X-Meta引擎是一个实时编程引擎</h3>

<p>&nbsp; &nbsp; 是因为：</p>

<ul>
	<li><strong>程序本身是模型数据</strong><br />
	程序本身是模型数据，而系统中的数据可以在运行时随时增加、修改和删除，所以构成程序的模型是可变的。<br />
	&nbsp;</li>
	<li><strong>实时解释模型是什么和如何执行</strong><br />
	我们编程是为了能够在系统中表示各种对象，并且能够正确的运行它们，X-Meta引擎提供了实时解释模型是什么、以及如何实时解释执行模型（动作）的方法。</li>
</ul>

<h3>6.2 XWorker是一个实时编程平台</h3>

<p>&nbsp; &nbsp; 是因为：</p>

<ul>
	<li><strong>XWorker是由各种模型组成的</strong><br />
	XWorker的是由构成它的模型所提供的。<br />
	&nbsp;</li>
	<li><strong>XWorker的核心是X-Meta引擎</strong><br />
	XWorker本身是由各种模型组成的，所以运行XWorker还是要通过X-Meta引擎，所以X-Meta引擎是XWorker的核心。<br />
	&nbsp;</li>
	<li><strong>XWorker的主要功能是管理事物</strong><br />
	管理事物的功能是由组成XWorker的模型提供的，通过XWorker随时可以添加和修改事物模型，而它的核心依然是X-Meta引擎，所以XWorker也是一个实时编程平台。</li>
</ul>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@basicConcepts
sname
basicConcepts
slabel
基本编程方法
stype
description
Sdescription
#$@text#$@
<h1>使用XWorker编程的基本方法</h1>

<h2>1.编程是为了表达对象</h2>

<p>&nbsp;&nbsp;&nbsp; 万物皆对象，这是面向对象编程的思想，同样我们认为在我们编程时就是为了在编程系统里把各种对象表示出来，如果这个对象具有行为，那么还能够正确的执行这些行为。</p>

<p>&nbsp;&nbsp;&nbsp; 而为了表示一个对象，就必须要能够表示它的实体（对象的属性）、对象的类别和行为等，本文则将说明如何使用事物和动作这两个基本概念来表示对象。</p>

<h2>2. 基本概念-事物</h2>

<p>&nbsp;&nbsp;&nbsp; 事物也可以指任何东西，在模型编程中每一个模型就代表了一个事物，模型的每一个节点都是一个独立的事物。</p>

<p>&nbsp;&nbsp;&nbsp; 由于事物就是模型，所以事物结构同模型的结构，一个事物是由属性和子事物构成的。</p>

<h2>3. 基本概念-动作</h2>

<p>&nbsp;&nbsp;&nbsp; 动作是可以执行的程序，在X-Meta引擎中认为任何一个事物都可以转化为动作，这参考了物质和能量的转化关系。</p>

<h2>4. 对象的表示</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;要表达对象的概念，实际就是如何使用事物和动作的概念来表示对象的实体、类别和行为等概念。</p>

<h3>4.1 对象的实体</h3>

<p>&nbsp;&nbsp;&nbsp; 我们知道对象的实体包含了对象的各种属性，通常可以把这些属性看作数据，而事物（模型）本身就是数据，所以可以用事物来直接表示对象的实体。</p>

<h3>4.2 对象的类别</h3>

<p>&nbsp;&nbsp;&nbsp; 当我们考察一个类时，必须要承认当前它就是我们的目标，因此类也是一个对象，所以表示类的方法也是表示对象的方法。</p>

<p>&nbsp;&nbsp;&nbsp; 那么一个对象在什么时候被称为类呢？我们认为就是使用它来描述另一个对象的时候。比如使用猫来描述那个小动物，此时那个小动物就是猫。这样就引出了模型编程中的第三个概念：<strong>描述者</strong>。</p>

<p>&nbsp;&nbsp;&nbsp; <strong>基本概念-描述者：</strong>当我们使用一个事物里描述另一个事物是，它就称为另一个事物的描述者，我们知道此时描述者也起到类的作用。</p>

<h3>4.3 对象的行为</h3>

<p>&nbsp;&nbsp;&nbsp; 由于行为是属于对象的，是对象的子集，而在模型编程中任何节点都可以转化为可执行的动作，所以我们可以约定一个事物的某些子节点是它的行为。</p>

<h2>5.基本编程方法总结</h2>

<h3>5.1 XWorker的基本编程方法</h3>

<p>&nbsp; &nbsp; XWorker的基本编程方法就是使用事物和动作这两个概念来表示对象，即用对象的实体是事物模型，对象的类别是事物模型之间的关系，对象的行为是事物模型的某些子节点。</p>

<h3>5.2 直接的面向对象的方法</h3>

<p>&nbsp;&nbsp;&nbsp;我们认为XWorker是一个更直接的面向对象的编程方法，是因为：</p>

<ul>
	<li><strong>万物皆对象</strong><br />
	至少在Java的面向对象的方法中提到，XWorker认为也是如此。<br />
	&nbsp;</li>
	<li><strong>类也是对象</strong><br />
	XWorker理清了类和对象的关系，首先类也是对象，其次类是对象之间的一种关系，还比如继承也是对象之间的关系。</li>
</ul>

<p>&nbsp; &nbsp; 综上所述XWorker其实是一个更直接的面向对象的编程方法。</p>

<h2>6. 编程示例</h2>

<p>&nbsp; &nbsp; 事物的结构和XML类似，我们可以使用XML来表示事物，下面用XML来展示。</p>

<h3>6.1 示例说明</h3>

<p>&nbsp; &nbsp; 比如我们现在用事物模型来表示一段表达式，在事物运行时计算出表达式的结果。</p>

<h3>6.2 定义事物</h3>

<p>&nbsp; &nbsp; 表达是事物可以定义为如下：</p>

<pre style="margin-left:40px">
&lt;thing name=&quot;expression&quot; code=&quot;3+2+5&quot;/&gt;</pre>

<p>&nbsp; &nbsp; 我们用事物的code属性来存储表达式。</p>

<h3>6.3 定义事物的行为</h3>

<p>&nbsp; &nbsp; 有了表达式的实体（即对象的属性），那么可以接着编写对象的行为。</p>

<pre style="margin-left:40px">
&lt;thing name=&quot;expression&quot; code=&quot;3+2+5&quot;&gt;
&nbsp;  &lt;actions&gt;
&nbsp;      &lt;JavaAction name=&quot;run&quot; code=&quot;//解释执行code代码&quot;/&gt;  
&nbsp;   &lt;/actions&gt;
&lt;/thing&gt;
</pre>

<p>&nbsp; &nbsp; 如上面的代码，我们为表达式对象定义了一个名为run的行为，run的行为负责解释执行表达式。这里可以看到run的行为也是事物模型，所以一样可以写成XML。</p>

<p>&nbsp; &nbsp; 注：JavaAction是示意代码，实际上在XWorker中的JavaAction也是可以直接写代码的。</p>

<h3>6.4 对象的调用</h3>

<p>&nbsp; &nbsp; X-Meta引擎是使用Java编写的，所以可以在Java代码里调用用事物模型所编写的对象。</p>

<pre style="margin-left:40px">
import org.xmeta.Thing;
import org.xmeta.World;
import org.xmeta.ActionContext;

public class Test{
&nbsp;   public void static run(String[] args){
&nbsp;       //World是管理事物的容器
 &nbsp;      World world = World.getInstance();
&nbsp;       
        //获取事物对象, path是事物的路径，规则基本同Class的名称
        Thing expression = world.getThing(path);
&nbsp;       
&nbsp;      //打印对象的属性
&nbsp;      System.out.println(thing.get(&quot;code&quot;));

&nbsp;      //执行run方法，其中actionContext是变量上下文
&nbsp;      expression.doAction(&quot;run&quot;, actionContext);
    }
}
</pre>

<h3>6.5 使用描述者简化事物对象的编写</h3>

<p>&nbsp; &nbsp; 描述者相当于事物对象的类，在面向对象中一个对象拥有它的类所定义的方法，所以我么可以定义一个描述者事物，在描述者事物里实现相关的行为。</p>

<pre style="margin-left:40px">
&lt;thing name=&quot;Expression&quot;&gt;
    &lt;attribute name=&quot;name&quot;/&gt;
    &lt;attribute name=&quot;code&quot;/&gt;
&nbsp;  &lt;actions&gt;
&nbsp;      &lt;JavaAction name=&quot;run&quot; code=&quot;//解释执行code代码&quot;/&gt;  
&nbsp;   &lt;/actions&gt;
&lt;/thing&gt;</pre>

<p>&nbsp; &nbsp; 在这里里我们定义一个名为Expression的事物，它定义了name和code两个属性，并且实现了一个名为run的行为，现在用它可以来表示具体的表达式事物了，比如：</p>

<pre style="margin-left:40px">
&lt;thing name=&quot;expressionTest&quot; code=&quot;3+2+5&quot; descriptors=&quot;Expression&quot;/&gt;</pre>

<p>&nbsp; &nbsp; 通过这种方法具体的表达式就不用再重写run方法了，只要描述者实现一次即可，另外在Java代码中，使用它们的方法是一样的。</p>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@builderThings
sname
builderThings
slabel
构建事物的方法
stype
description
Sdescription
#$@text#$@
<h1>构建事物的方法</h1>

<h2>1 在运行时增加和修改事物模型</h2>

<p>&nbsp; &nbsp; 我们知道XWorker是一个实时编程平台，实时的意思就是在系统运行的时候编程，那现在就存在一个问题，如何在运行时增加和修改事物模型。</p>

<p>&nbsp; &nbsp; 也许你会说我们可以像其它编程方法一样，预先编写好事物模型的代码，然后在系统运行起来的时候装载它们就好，但这就是失去了实时编程的意义。</p>

<p>&nbsp; &nbsp; 因此我们需要一个在运行时的管理事物的工具，还需要一个编辑事物的工具，这样可以在运行时增加和修改事物。</p>

<h2>2. 编辑和构建事物的原理</h2>

<p>&nbsp; &nbsp; 事物模型是数据，在运行时增加和删除数据是容易的，而如何编辑它们需要一定的方法，下面就是事物编辑器的方法原理。</p>

<h3>2.1 通过事物的结构来编辑事物</h3>

<p>&nbsp; &nbsp; 我们知道事物模型的结构和XML类似，因此可以使用XML的结构(Schema或DTD）来编辑XML的方法来编辑事物。</p>

<p>&nbsp; &nbsp; 具体就是如果知道了事物的结构，那么就可以通过事物的结构知道事物应该有属性和子节点，这样就可以编写一个事物编辑工具，在事物编辑工具里根据结构所指定的属性动态生成属性编辑界面，通过结构指定的子节点决定有哪些子节点可以添加。</p>

<h3>2.2 终极结构</h3>

<p>&nbsp; &nbsp; 在XWorker里有一个简单的定义事物模型的结构方法，那就是结构只描述事物有哪些属性和子事物，这样的结果是任何一个事物模型的结构还是一个事物模型。</p>

<p>&nbsp; &nbsp; 如果一个事物模型的结构还是事物模型，那么任意一个事物模型的结构的结构会是怎样的呢？通过演算发现任何事物模型的结构的结构是唯一的，我们命名这个结构为<strong>元事物</strong>。</p>

<h3>2.3 元事物的意义</h3>

<p>&nbsp; &nbsp; 由于元事物是任意事物的结构的结构，因此从使用事物的结构来编辑事物这个方法来看，使用元事物作为起始结构，就可以直接或者间接的编辑出任意事物来了。</p>

<p>&nbsp; &nbsp; 这就是XWorker的事物编辑器的原理，也是构建事物的基本方法。</p>

<h2>3. 元事物的发现过程</h2>

<p>&nbsp; &nbsp; 事物模型的结构同XML，所以下面用XML来表示事物模型。</p>

<h3>3.1 事物结构的定义</h3>

<p>&nbsp; &nbsp; 由于事物（模型）是由节点和属性组成的，因此事物的结构就定义为描述事物的节点和属性的方法。</p>

<p>&nbsp; &nbsp; 使用XML来表示，如果一个事物是：</p>

<pre style="margin-left: 40px;">
&lt;Person name=&quot;tom&quot; age=&quot;10&quot;/&gt;</pre>

<p>&nbsp; &nbsp; 那么它的结构就可以表示为：</p>

<pre style="margin-left: 40px;">
&lt;thing name=&quot;Person&quot;&gt;
&nbsp;   &lt;attribute name=&quot;name&quot;/&gt;
&nbsp;   &lt;attribute name=&quot;age&quot;/&gt;
&lt;/thing&gt;
</pre>

<p>&nbsp; &nbsp; 可以看到这里用&lt;thing name=&quot;xxx&quot;/&gt;来描述事物的节点，使用&lt;attribute name=&quot;xxx&quot;/&gt;来描述节点的属性。</p>

<h3>3.2&nbsp;事物的结构的结构</h3>

<p>&nbsp; &nbsp; 使用以上事物的结构定义，可以发现事物的结构还是一个事物，那么依据事物结构的定义，还可以继续找事物的结构的结构。</p>

<p>&nbsp; &nbsp; 这是一个无限递归的操作。</p>

<h3>3.3&nbsp;元事物</h3>

<p>&nbsp; &nbsp; 如果无限递归的寻找事物的结构的结构，那么会发现最终的结果是一样的，即存在一个事物它的结构就是它自己，这个结构事物称为元事物。</p>

<p>&nbsp; &nbsp; 拿起纸和笔可以很容易验证这个结果，这里就不详细说明了，最后元事物如下：</p>

<pre style="margin-left: 40px;">
&lt;thing name=&quot;thing&quot;&gt;
    &lt;attribute name=&quot;name&quot;/&gt;
    &lt;thing name=&quot;attribute&quot;&gt;
&nbsp;       &lt;attribute name=&quot;name&quot;/&gt;
    &lt;/thing&gt;
&nbsp;  &lt;thing name=&quot;thing&quot;&gt;
&nbsp;       //无限重复根节点
&nbsp;   &lt;/thing&gt;
&lt;/thing&gt;
</pre>

<p>&nbsp; &nbsp; 最后会发现元事物是一个有无限深子节点的，且每层节点都一样的事物。</p>

<h2>4 总结</h2>

<h3>4.1 事物管理器</h3>

<p>&nbsp; &nbsp; 使用事物的结构可以用来构建和编辑具体的事物，XWorker用这个原理编写一个事物管理器，通过事物管理器可以编写各种事物了。</p>

<h3>4.2 开始编程吧</h3>

<p>&nbsp; &nbsp; 到这里已经把事物模型编程的基本理论知识讲完了，可以实际的用它编写一些程序了，请看后续的其它教程。</p>

<h2>5 关于动作的执行的疑问</h2>

<p>&nbsp; &nbsp; 本文介绍了如何构建和编辑事物模型的方法，实际上这是一个递归的操作，那么关于动作的执行是否也具有类似的原理和效果呢？</p>

<p>&nbsp; &nbsp; 同样的问题也可以是对于任意一个动作模型，它是否可以正确执行的问题，答案就是编程语言的原理，一个动作的执行最终是递归到Java语言，最最后是递归到机器语言上，因此最终在执行的还是CPU。</p>

<p>&nbsp; &nbsp; 关于动作的执行的补充，是为了让大家不要认为模型编程有局限性，毕竟XWorker是使用Java编写的，它是Java之上的一个系统，实际上它的局限性是由Java决定的。</p>

<p>&nbsp; &nbsp; 但实际上，模型的实时编程方法用其它语言也可以实现，如果有可能我希望它在操作系统层，或硬件层实现。</p>

<p>&nbsp;</p>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@createAndEditThing
sname
createAndEditThing
slabel
创建和编辑事物
spath
xworker.example.xworker.base.CreateAndEditThingAutoDemo
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@unstandAction
sname
unstandAction
slabel
使用动作
stype
description
Sdescription
#$@text#$@
<h1>使用动作</h1>

<h2>1. 动作是可以执行的程序</h2>

<p>&nbsp;&nbsp;&nbsp; 现在我们知道了XWorker是一个模型编程平台，模型可以转化为动作，动作是可以执行的。但是动作是怎样执行的呢？任何一个模型转化后的动作都能正确执行么？本文将回答这些问题。</p>

<h2>2. 基本动作:JavaAction</h2>

<p>&nbsp;&nbsp;&nbsp; 如果一个动作的事物名是JavaAction，那么它就是基本动作，基本动作是由X-Meta引擎直接解释执行的。</p>

<h3>2.1&nbsp;JavaAction动作模型示例</h3>

<p style="margin-left: 40px;"><img alt="" src="do?sc=xworker.ide.worldexplorer.swt.http.SwtImage&amp;shell=xworker.example.xworker.base.JavaActionExample&amp;control=thingEditor.mainComposite" style="height:451px; width:634px" /></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图是一个JavaAction的示例，在这个模型里指定了Java的类全名和要执行的方法，这样X-Meta引擎就知道要找那个类执行那个方法了。</p>

<h3>2.2 JavaAction的Java代码示例</h3>

<pre class="brush:java;" style="margin-left: 40px;">
package xworker.swt.widgets;

public class ShellCreator{
     //X-Meta引擎能够调用的方法必须是静态方法，且参数固定为ActionContext
     public static Object create(ActionContext actionContext){
            //相关代码
     }
}</pre>

<p>&nbsp;&nbsp;&nbsp;如上面代码示例，X-Meta引擎调用静态的且参数必须是ActionContext的方法，如果JavaAction指定了合适的类和方法，那么X-Meta引擎就可以正确调用了。</p>

<h2>3&nbsp;变量上下文ActionContext</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;在JavaAction的Java代码里我们看到方法的参数是ActionContext，ActionContext的名称叫做变量上下文（或动作上下文），它的主要作用是保存变量用的。</p>

<h3>3.1&nbsp;变量上下文的基本用法</h3>

<pre class="brush:java;" style="margin-left: 40px;">
//变量上文的基本用法是保存变量和获取变量

//保存变量
actionContext.put(&quot;varName&quot;, varObject);

//获取变量
Object varObject = actionContext.get(&#39;varName&quot;);</pre>

<h3>3.2&nbsp;变量上下文也是一个栈</h3>

<pre class="brush:java;" style="margin-left: 40px;">
//变量上下文本身也是一个栈，栈中的每一个层是Bindings对象，Bindings可以保存变量

//压栈
Bindings bindings = actionContext.push();

//顶端的栈
Bindings bindings = actionContext.peek();

//出栈
Bindings bindings = actionContext.pop();

//使用Bindings设置变量和获取变量的值
bindings.put(&quot;varName&quot;, varObject);

Object varObject = bindings.get(&quot;varName&quot;);</pre>

<h3>3.3&nbsp;变量上下文的取值和赋值是自上而下的</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;变量上下文是一个栈，从变量上下文取参数时是自上而下获取的，也就是说如果不同的栈层的Bindings包含同样的变量名，那么只会取到顶端第一个包含变量名的那个栈层的变量。</p>

<pre class="brush:java;" style="margin-left: 40px;">
//压入第一个栈
Bindings bindings1 = actionContext.push();
bindings1.put(&quot;name&quot;, &quot;tom&quot;);

//压入第二个栈
Bindings bindings2 = actionContext.push();
bindings2.put(&quot;name&quot;, &quot;Smith&quot;);

//此时控制输出的是顶端栈中的Smith
System.out.println(actionContext.get(&quot;name&quot;));

//弹出顶端的栈
actionContext.pop();

//此时控制台输出的tom
System.out.println(actionContext.get(&quot;name&quot;));</pre>

<h3>3.4&nbsp;使用变量上下文传递参数</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;使用变量上下文是一个栈和取变量的自上而下的特性，可以在调用一个动作前压入一个栈，在这个栈中存放参数变量，从而实现传递参数的功能。</p>

<h3>3.5&nbsp;线程安全</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;变量上下文的栈是ThreadLocal的，即每个线程拥有一个独立栈，因此变量上下文是线程安全的，变量上下的栈是由各自的线程维护的。</p>

<h3>3.6&nbsp;全局变量和局部变量</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;变量上下文的0层栈是每个线程都共有的，因此0层栈的变量相对来说是全局的，而非0层的栈则可以认为是局部的。</p>

<h2>4&nbsp;调用动作</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;动作是可以执行的程序，可以在代码中调用动作。由于X-Meta引擎是使用Java编写的，所以可以在Java代码中调用动作。</p>

<h3>4.1&nbsp;调用动作的一般方法</h3>

<pre class="brush:java;" style="margin-left: 40px;">
//获取模型事物，其中World是管理事物的容器类，path是事物的路径
Thing thing = World.getInstance().getThing(&quot;path&quot;);

//转化为动作，任何事物都可以转化为动作
Action action = thing.getAction();

//创建变量上下文
ActionContext actionContext = new ActionContext();

//执行动作
action.run(actionContext);</pre>

<h3>4.2&nbsp;通过事物的行为来调用动作</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;在用对象的角度看待事物时，事物是具有行为的，调用事物行为的示例如下。</p>

<pre class="brush:java;" style="margin-left: 40px;">
//获取模型事物，其中World是管理事物的容器类，path是事物的路径
Thing thing = World.getInstance().getThing(&quot;path&quot;);

//创建变量上下文
ActionContext actionContext = new ActionContext();

//执行事物的行为run
thing.doAction(&quot;run&quot;, actionContext);</pre>

<p>&nbsp;&nbsp;&nbsp;&nbsp;可以看到事物的行为是通过doAction方法调用的。</p>

<h3>4.3&nbsp;动作和行为的差别</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;首先行为也是动作，只是一个动作被当成了某个对象的行为，其次行为是通过模型寻找到的某个子模型，最后在代表行为的子模型转化为动作执行前，最为对象的模型本身会以名为self的参数放到变量上下文中。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;所以动作执行时没有self参数，而行为执行时是有self参数的，这里self变量类似Java的this变量的效果。</p>

<h2>5&nbsp;其他非基本类型的动作</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;JavaAction是基本类型的动作，但JavaAction也有一点缺陷，那就是Java代码通常是模型之外东西，就算在JavaAction模型中直接写Java代码，那么也是很繁琐的。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;基于以上原因，我们利用事物的行为来实现脚本动作或其它非JavaAction的动作。</p>

<h3>5.1&nbsp;非JavaAction的动作实现原理</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;首先在模型编程中动作本身也是模型，因此动作也可以当做对象来看待，如果把动作当做对象来看待，那么动作就具有行为，此时就可以把对象名为run的行为当成它的执行动作了。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;这有点类似java.lang.Runnable这个类，动作是可以执行的，只要实现它的run方法就可以了。</p>

<h3>5.2&nbsp;GroovyAction<br />
&nbsp;&nbsp;&nbsp;&nbsp; GroovyAction是一个脚本动作，使用它可以直接编写Groovy脚本，能够快速编写动作的代码。</h3>

<p style="margin-left: 40px;"><img alt="" src="do?sc=xworker.ide.worldexplorer.swt.http.SwtImage&amp;shell=xworker.example.xworker.base.GroovyActionExample&amp;control=thingEditor.mainComposite" style="height:451px; width:634px" /></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图是GroovyAction的示例，在GroovyAction里脚本是直接写到代码里的。</p>

<h3>5.3&nbsp;其他动作</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;通过实现事物的run方法，可以实现各种类型的动作，比如支持Jython、Lua等其他语言的动作，也比如Begin、If、while、for这样的控制语句的动作，也可以实现其它效果的动作。</p>

<h2>6.&nbsp;总结</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;本文讲述动作和变量上下文（ActionContext）的基本概念，也讲述了如何使用动作的方法。</p>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@distributeApp
sname
distributeApp
slabel
应用部署
stype
description
Sdescription
#$@text#$@
<h1>应用部署</h1>

<h2>1.&nbsp;发布在XWorker编写的应用</h2>

<p>&nbsp;&nbsp;&nbsp; XWorker是一个编程平台，当程序编写好后就会考虑如何发布和部署，下面是部署XWorker应用的几个典型方法。</p>

<h2>2.&nbsp;在XWorker中运行应用</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;这种方法就不需要发布应用，在XWorker中编写在XWorker中运行。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;如果需要把应用给其他人使用，那么把相关事物拷贝到其他人的XWorker的对应目录下即可。</p>

<h2>3.&nbsp;在XWorker之外运行</h2>

<p>&nbsp;&nbsp;&nbsp; XWorker可以像Ant和Maven一样作为一个单独的应用放到某个目录下，然后事物是编写在其他目录下的，此时可以通过XWorker目录下的xer.cmd或xer.sh命令来执行当前目录下的事物。</p>

<h2>4.&nbsp;把事物打包到Jar或War中</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;事物可以放到Java的类路径中，因此可以把自己的事物打包到jar或war中，此时只要包含X-Meta引擎的少数几个相关类库，在程序中初始化其它目录下的XWorker，也一样可以运行事物。</p>

<h2>5.&nbsp;把XWorker打包到Jar或War中</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;同4的方法，只是不把XWorker放到单独的目录下，而是直接把XWorker打包，此时需要注意的是要发布的程序可能用不上XWorker所包含的那么多第三方类库，打包时需自行考虑打包哪些内容。</p>

<h2>6.&nbsp;只使用X-Meta引擎</h2>

<p>&nbsp;&nbsp;&nbsp; XWorker的核心是X-Meta引擎，此时可以只把XWorker当做一个事物的编辑器。</p>

<p>&nbsp;</p>
#$@text#$@
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@HTML
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@ProgramTutorials/@Example
sname
Example
slabel
编程示例
spath
xworker.example.xworker.model.ModelExamples
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@programUp
sname
programUp
slabel
编程进阶
sdescription
<p>模型编程进阶知识。</p>
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@Node
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@programUp/@defineNewTypeThing
sname
defineNewTypeThing
slabel
如何定义新事物
spath
xworker.demo.xworker.base.Program2
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@programUp/@actionAndBehavior
sname
actionAndBehavior
slabel
动作和行为详解
spath
xworker.demo.xworker.editor.ThingAction
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@programUp/@ThingEditor
sname
ThingEditor
slabel
事物编辑器指南
spath
xworker.demo.xworker.editor.ThingEditor
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@programUp/@webExample
sname
webExample
slabel
Web模型示例
spath
xworker.demo.xworker.demo.WebDemo
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@XWorkerTutorials/@programUp/@ImportExample
sname
ImportExample
slabel
导入其他类库示例
spath
xworker.demo.xworker.demo.ImportDemo
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@swt
sname
swt
slabel
SWT指南
sdescription
<p>SWT编程指南。</p>
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@Node
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@swt/@swtTutorials
sname
swtTutorials
slabel
SWT入门
sdescription
<p>SWT编程的基本知识。</p>
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@Node
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@swt/@swtTutorials/@base
sname
base
slabel
基础知识
spath
xworker.swt.help.base.SwtBase
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@swt/@swtTutorials/@commonControls
sname
commonControls
slabel
常用控件
spath
xworker.swt.help.base.NormalControls
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
@/@swt/@swtTutorials/@commonLayouts
sname
commonLayouts
slabel
常用布局
spath
xworker.swt.help.base.NormalLayouts
sdescriptors
xworker.swt.xwidgets.DemoMixMenu/@AutoDemo
sinheritDescription
false
sth_createIndex
false
sth_registMyChilds
false
sth_registDisabled
false
sth_mark
false
